===================================================================================================
Resources:
===================================================================================================

https://docs.djangoproject.com/en/4.2/ref/
https://docs.djangoproject.com/en/4.2/contents/
https://docs.djangoproject.com/en/4.2/topics/
https://docs.djangoproject.com/en/3.2/contents/

https://www.geeksforgeeks.org/tag/python-django/

https://www.tutorialspoint.com/django/index.htm

**********************

Hi, thanks for joining the coding community!
Every month, i will send you a summary of all my latest content, which includes my newest videos, blog posts and programming tips.
In the mean time,you can check out my youtube channel where i teach programming:
https://www.youtube.com/c/CodeWithTomi


Free Resources:

Django Roadmap: https://www.dropbox.com/s/opzvs43bwqpvr8c/Django%20Roadmap%20-%20Google%20Docs.pdf?dl=0

Django Projects Cheat Sheet: https://www.dropbox.com/s/s54nyhbslh8fqxg/Django%20Projects%20cheat%20sheet%20-%20Google%20Docs.pdf?dl=0

Python Data Structures: https://www.dropbox.com/s/bpof9qic77kjlfj/PYTHON%20DATA%20STRUCTURES%20%281%29.pdf?dl=0

Git Cheat Sheet: https://www.dropbox.com/s/ubyvjp84cq42m5r/Git%20Cheat%20Sheet%20-%20Google%20Docs.pdf?dl=0


===================================================================================================
frequently used commands
===================================================================================================

1) reload shell:
exit()
python manage.py shell
from my_models.models import *
from many_to_many_relationship.models import *
from many_to_one_relationship.models import *

2) migrate:
python manage.py makemigrations
python manage.py migrate


===================================================================================================
initial Setup (using pipenv)
===================================================================================================

pipenv:

https://medium.com/@piyushmaurya23/setting-up-django-using-pipenv-cf8ff9b2caa6

1. Make a directory for the django project
2. Install 'pip install pipenv' in the system environment if not already
3. Create a virtual environment by running 'pipenv shell'
    (the location of the venv defaults to '~/user/.virtualenv/', to make it live inside the current directory, make an empty folder named '.venv',
    pipenv automatically detects that folder and creates the virtual environment inside that folder)
    ( default location in my ubuntu: /home/dev/.local/share/virtualenvs/Projects-IqmR9ahX )
4. Now install django by running 'pipenv install django' (installs the latest version)
5. Start the project by running 'django-admin startproject $NAME_OF_THE_PROJECT'
6. To start the live server cd into the project and run 'python manage.py runserver port(optional)'
7. To make a new app inside that project run 'python manage.py startapp $NAME_OF_THE_APP'


show all packages installed globally
> pip freeze


create env with requirement.txt file:
> pipenv install -r ./requirements.txt

check any security issue in installed packages:
> pipenv check
update in pipfile and run "pipenv install"


show dependencies
pipenv graph


update lock file with the installed version in case you install latest version of some package and it shows "*" in pipfile and then insatll using lock file when you deploy:
pipenv lock

pipenv install --ignore-pipfile



run command in virtual environment without activating it:
pipenv run python


**********************
summary:

Go into dir where you want your virtual environment:

First install pipenv using "pip install pipenv"

1) create ".venv" director,
2) pipenv install             --  will create Pipfile and lock file and create virtual environment
3) pipenv install django      -- install package
4) pipenv shell		      -- activate virtual environment

5) Create a new Django project called P1_DjangoModels with the following command.

django-admin startproject P1_DjangoModels .              -- create project in the same dir

django-admin startproject P1_DjangoModels		   -- create project in its sub directory


===================================================================================================
Initial Setup (old)
===================================================================================================

https://www.youtube.com/watch?v=UmljXZIypDc&list=PL-osiE80TeTtoQCKZ03TU5fNfx2UY6U4p&index=1&t=405s
corey schafer
https://github.com/CoreyMSchafer/code_snippets/tree/master/Django_Blog
*********************************************

pip install django

python -m django --version
or
python -c "import django; print(django.get_version())"

django-admin     --------  list all sub-commands

*********************************************

create project:

django-admin startproject project_name

wsgi  how our web_application and browser_server will commmunicate

*********************************************


python manage.py runserver

http://localhost:8000/
http://127.0.0.1:8000/


ctrl+c to stop server

*********************************************


Django documentation

https://docs.djangoproject.com/en/3.2/

*********************************************

a single project can contain multiple apps

python manage.py startapp name_of_app

python manage.py startapp blog

python manage.py startapp users


*********************************************
Create app inside project:

1) python manage.py startapp name_of_app

python manage.py startapp my_models

2) Register app in installed_app in settings.py file:

INSTALLED_APPS = [
    # ...
    'my_models.apps.MyModelsConfig',
    # ...
]

3) Add urls of the app in main urls.py:

a) create urls.py file in app.
b) register this url file in main urls.py:
    from django.contrib import admin
    from django.urls import path, include

    urlpatterns = [
        path('admin/', admin.site.urls),
        path('', include('blog.urls')),
    ]

4) add model in current app's admin.py file:

from django.contrib import admin
from .models import Person

admin.site.register(Person)


**********************************

naming convention for apps:

Here are a few examples of app names following the convention:

blog (for a blogging app)
ecommerce (for an e-commerce app)
user_profile (for a user profile app)
inventory_management (for an inventory management app)
event_calendar (for an event calendar app)


===================================================================================================
Day 1:
Models
===================================================================================================

debugging:

import pdb; pdb.set_trace()

*************************

diff ways of getting sql in shell:

1) paster in shell:

import logging
log = logging.getLogger('django.db.backends')
log.setLevel(logging.DEBUG)
log.addHandler(logging.StreamHandler())

2) for simple logs add this code to settings.py file:

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'DEBUG',  # Set this to the desired logging level
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'level': 'DEBUG',  # Set this to the desired logging level
            'propagate': False,
        },
    },
}

3) add this code to settings.py for formatted sql:

import sqlparse
import logging

class SqlFormatter(logging.Formatter):
    def format(self, record):
        statement = record.getMessage()
        formatted_statement = sqlparse.format(statement, reindent=True)
        return formatted_statement


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'sql',  # Use the 'sql' formatter for SQL queries
        },
    },
    'formatters': {
        'sql': {
            '()': SqlFormatter,  # Use the full path to your custom formatter class
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'DEBUG',  # Set this to the desired logging level
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'l
===================================================================================================
pipenv initial
===================================================================================================

https://medium.com/@piyushmaurya23/setting-up-django-using-pipenv-cf8ff9b2caa6

1. Make a directory for the django project
2. Install 'pip install pipenv' in the system environment if not already
3. Create a virtual environment by running 'pipenv shell' (the location of the venv defaults to '~/user/.virtualenv/',
	 to make it live inside the current directory, make an empty folder named '.venv', pipenv automatically detects that folder and creates the virtual environment inside that folder)
4. Now install django by running 'pipenv install django' (installs the latest version)
5. Start the project by running 'django-admin startproject $NAME_OF_THE_PROJECT'
6. To start the live server cd into the project and run 'python manage.py runserver port(optional)'
7. To make a new app inside that project run 'python manage.py startapp $NAME_OF_THE_APP'


show all packages installed globally
> pip freeze


create env with requirement.txt file:
> pipenv install -r ./requirements.txt

check any security issue in installed packages:
> pipenv check
update in pipfile and run "pipenv install"


show dependencies
pipenv graph


update lock file with the installed version in case you install latest version of some package and it shows "*" in pipfile and then insatll using lock file when you deploy:
pipenv lock

pipenv install --ignore-pipfile



run command in virtual environment without activating it:
pipenv run python


**********************


Go into dir where you want your virtual environment:

First install pipenv using "pip install pipenv"

1) create ".venv" director,
2) pipenv install             -- will create Pipfile and lock file and create virtual environment
3) pipenv install django      -- install package
4) pipenv shell		          -- activate virtual environment

5) Create a new Django project called P1_DjangoModels with the following command.

django-admin startproject P1_DjangoModels .              -- create project in the same dir

django-admin startproject P1_DjangoModels		   -- create project in its sub directory

evel': 'DEBUG',  # Set this to the desired logging level
            'propagate': False,
        },
    },
}

4) If you're in the shell, or anywhere for that matter, you can use the queryset method

query.as_sql()
to print the SQL command.

ie:

MyModel.objects.all().query.as_sql()




===================================================================================================
Django Basics
===================================================================================================

Create Project heirarchy

1) Create virtual environment:

python -m venv myenv        -- create virtual environment
myenv\Scripts\activate      -- activate it

pip install django
pip install django-crispy-forms

2) django-admin startproject djangoPractice

3) To create your app, make sure you’re in the same directory as manage.py and type this command:
   python manage.py startapp myapp

4) Its useful to register app in settings.py file immediately
	'myapp.apps.MyappConfig'


myenv\Scripts\activate
cd mysite


python manage.py runserver


********************************************

Create views

1) create urls.py in the app

2) include this url file in main url file

from django.contrib import admin
from django.urls import path, include

urlpatterns = [                                  # note write / after route else it cause error
    path('admin/', admin.site.urls),
    path('myapp/', include('myapp.urls'))
]


3) craeate urls + views

from django.urls import path
from . import views

urlpatterns=[
    path( '', views.index , name="index" )

]

from django.http import HttpResponse
def index(requuest):
     return HttpResponse("hello world")



**********************************************

render html :

1) first register app in settings.py file
'myapp.apps.MyappConfig'

2) create templates in myapp  ( by default django look in templates folder as base directory )

myapp -> templates  -> myapp -> index.html

3) create view

from django.shortcuts import render

def index2(request):
    return render(request, "myapp/index.html")

*******

Your project’s TEMPLATES setting describes how Django will load and render templates.
The default settings file configures a DjangoTemplates backend whose APP_DIRS option is set to True. By convention DjangoTemplates looks for a “templates” subdirectory in each of the INSTALLED_APPS.

*********

Here’s a setup that tells the Django template engine to load templates from the templates subdirectory inside each installed application:

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "APP_DIRS": True,
    },
]


****************************************************

creating models:

1)

create model in model class ----

from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    date_posted = models.DateTimeField(default=timezone.now)
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    # on_delete : if the user is deleted , then we want to delete their posts as well

    def __str__(self):  # dunder(double underscore) str method
        return self.title


# DateTimeField(auto_now = True)   -> for last modified field
# DateTimeField(auto_now-add = True)   -> save current date when object is created but we cannot modify that date

2)

create models and register in admin.py file in app

from .models import Post
admin.site.register(Question)


3)

To run migrations we first need to create super user

	python manage.py createsuperuser

3)

Re run the Migrations commands in order to get changes to our database.

a) python manage.py makemigrations

b) python manage.py sqlmigrate blog 0001   #  it prints out the code that is going to run

c) python manage.py migrate


***************************************************

Manipulate database

see official docs   ---  https://docs.djangoproject.com/en/4.0/intro/tutorial02/

Create User in cmd  ---  https://www.codegrepper.com/code-examples/python/django+add+user+command+line

1) python manage.py shell

2) >>> from app.Models import Post
3) >>> from django.contrib.auth.models import User

4) User.objects.all()
4) User.objects.first()
4) User.objects.filter(username='nouman')
4) User.objects.filter(username='nouman').first()


5) a) user = User.objects.filter(username='nouman').first()
   b)  user.post_set
   b)  user.post_set.all()


6) exit()  to exit from shell

see database.txt also



===================================================================================================
https://stackoverflow.com/questions/75495403/django-returns-templatedoesnotexist-when-using-crispy-forms

Forms:

1) As of django-crispy-forms 2.0 the template packs are now in separate packages.
Install both packages:

pip install django-crispy-forms
pip install crispy-bootstrap4


2)register this app in settings.py
'crispy_forms',
'crispy_bootstrap4',

3) CRISPY_TEMPLATE_PACK = 'bootstrap4'

4) create forms.py file and creaete form:

from django import forms
class PostForm(forms.Form):
    title = forms.CharField(max_length=100)
    content = forms.CharField(widget=forms.Textarea)



5) create view as :

def new_post(request):
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = PostForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            title = form.cleaned_data['title']
            content = form.cleaned_data['content']
            post = Post(title=title, content=content, author_id=1)
            post.save()
            return redirect('posts')
    else:
        form = PostForm()
    return render(request, 'myapp/myForm.html', {'form': form})


4) create html file myForm.html
inside your_html.html file add {% load crispy_forms_tags %} and you can use cripy_forms as you like

************************************



load static data:


add this in settings.py file  ---  STATIC_URL = '/static/'

by default django look static file in this heirarchy ( so create this structure)
app -> static-> app-> staticfile

to add static file in html page:

{% load static %}

 <link rel="stylesheet" type="text/css" href="{% static 'myapp/bootstrap.min.css' %}">

===================================================================================================
Django Basic Lines:
===================================================================================================


from django.contrib import admin
from django.contrib.auth import views as auth_views
from django.urls import path, include
from users import views as user_views

urlpatterns = [
    path('admin/', admin.site.urls),
    # path('blog/', include('blog.urls')),    # all the blog views will start from  blog/...
    path('', include('blog.urls')),
    path('register/', user_views.register, name='register'),
    path('login/', auth_views.LoginView.as_view(), name='login'),
    path('logout/', auth_views.LogoutView.as_view(), name='logout'),
]

****************************


# names can be used to redirect to this specific route as

return redirect('register')

<a class="ml-2" href="{% url 'register' %}">Sign Up Now</a>

********************************************

href="{% url 'post-detail' post.id %}"   in html file ( blog app)

path('post/<int:pk>/', PostDetailView.as_view(), name='post-detail')


===================================================================================================
Django Ecommerce
===================================================================================================


Check Python
check pip
create project
connect database in setting.py



Part 2
1. Create App = store
2. Register The app in settings.py
3. INclude the app's urls.py file in the main urls file
4. create the templates structure
5. Create the home path and views function and render the index.html template


part 3:
1. create category and product models and register in admin.py file
2. make migrations and migrate
	(env) D:\Python Django Project\Ecommerce Website>       python manage.py makemigration
	(env) D:\Python Django Project\Ecommerce Website>	pythom manage.py migrate


3. create superuser

	python manage.py createsuperuser

	(env) D:\Python Django Project\Ecommerce Website>python manage.py createsuperuser
	Username (leave blank to use 'nouman'):
	Email address: noumanrehman042@gmail.com
	Password: 1234 (invisible)
	Password (again):1234
	This password is too short. It must contain at least 8 characters.
	This password is too common.
	This password is entirely numeric.
	Bypass password validation and create user anyway? [y/N]: y
	Superuser created successfully.


4. pip install django-jazzmin
  and register it in installed apps as 'jazzmin' in settings.py file


8. Django Ecommerce Part 8 | User registration in django | Custom User register form using bootstrap
	User registration in django:

https://www.youtube.com/watch?v=q6oxoOxvUMk&list=PL_99hMDlL4d2zsGU5nOgADmRc6A8msXyh&index=8





===================================================================================================
Django Installations
===================================================================================================

pip install django

pip install django-crispy-forms

pip install Pillow    --   library to work with images with python


===================================================================================================
Python linters
===================================================================================================

Difference Between Linter and Formatter?
Linter analyzes code for errors, potential issues, and adherence to coding standards, providing suggestions and warnings.
Formatter automatically adjusts code formatting to conform to a specific style guide, ensuring consistent and uniform code appearance.



===================================================================================================
Django Apps
===================================================================================================

https://docs.djangoproject.com/en/4.2/ref/applications/

Django contains a registry of installed applications that stores configuration and provides introspection.
It also maintains a list of available models.

This registry is called apps and it’s available in django.apps:

>>> from django.apps import apps

>>> apps.get_app_config("admin").verbose_name
'Administration'

>>> apps.ready
Boolean attribute that is set to True after the registry is fully populated and
all AppConfig.ready() methods are called.


>>> apps.get_app_configs()
It Returns an iterable of AppConfig instances.

dict_values([<AdminConfig: admin>, <AuthConfig: auth>, <ContentTypesConfig: contenttypes>,
<SessionsConfig: sessions>, <MessagesConfig: messages>, <StaticFilesConfig: staticfiles>,
<MyViewsConfig: my_views>, <AppConfig: crispy_forms>, <PollsConfig: polls>,
<MyClassBasedViewsConfig: my_class_based_views>, <EmployeeAppConfig: employee_app>,
 <BookshelfConfig: bookshelf>, <TaskManagerConfig: task_manager>])

>>> apps.get_app_config(app_label)

apps.get_app_config('polls')
<PollsConfig: polls>

Returns an AppConfig for the application with the given app_label.
Raises LookupError if no such application exists.


*************

>>> apps.get_model("polls", "Question")
>>> apps.get_model("polls.Question")
>>> apps.get_model("polls.question")

syntax:
apps.get_model(app_label, model_name, require_ready=True)¶

Returns the Model with the given app_label and model_name.
As a shortcut, this method also accepts a single argument in the form app_label.model_name.
model_name is case-insensitive.


****************************
All methods of apps registry:

>>> from django.apps import apps

methods we can use with this 'apps':

apps.all_models                    apps.clear_cache(                  apps.get_model(                    apps.lazy_model_operation(         apps.ready_event                   apps.unset_available_apps(
apps.app_configs                   apps.do_pending_operations(        apps.get_models(                   apps.loading                       apps.register_model(               apps.unset_installed_apps(
apps.apps_ready                    apps.get_app_config(               apps.get_registered_model(         apps.models_ready                  apps.set_available_apps(
apps.check_apps_ready(             apps.get_app_configs(              apps.get_swappable_settings_name(  apps.populate(                     apps.set_installed_apps(
apps.check_models_ready(           apps.get_containing_app_config(    apps.is_installed(                 apps.ready                         apps.stored_app_configs


****************************
Application configuration
****************************

class AppConfig:
Application configuration objects store metadata for an application.
Some attributes can be configured in AppConfig subclasses. Others are set by Django and read-only.

>>> from django.apps import apps

>>> app_config = apps.get_app_config('polls')
<PollsConfig: polls>

>>> app_config.verbose_name
'Polls'

>>> app_config.name
'polls'

>>> app_config.label
'polls'

>>> app_config.path
'/home/dev/django_training/Projects/P2_DjangoBasics/polls'


>>> app_config.module
<module 'polls' from '/home/dev/django_training/Projects/P2_DjangoBasics/polls/__init__.py'>

All methods on app_config:

app_config.apps                app_config.get_model(          app_config.label               app_config.module              app_config.ready(
app_config.create(             app_config.get_models(         app_config.models              app_config.name                app_config.verbose_name
app_config.default_auto_field  app_config.import_models(      app_config.models_module       app_config.path

********************************

Initialization process:

https://docs.djangoproject.com/en/4.2/ref/applications/#initialization-process

In Django, when the framework starts up, the django.setup() function is responsible for populating the application registry and performing various initialization tasks.
The setup() function is typically called automatically when Django's management commands or server are run.

The django.setup() function performs several important tasks:

1) Populating the Application Registry: As you mentioned, one of the main tasks of setup() is to populate the application registry.
It does this by scanning the installed apps and their corresponding AppConfig classes.
Each application's AppConfig class provides metadata and configuration for the application, such as its name, label, models, middleware, and other settings.

2) Setting Up Settings: The setup() function also ensures that the settings for the project are properly configured and ready to be used. This includes loading settings from the project's settings.py file and applying any necessary modifications.

3) Loading Middleware: Middleware components are classes that process requests and responses globally in Django. The setup() function loads and configures the middleware defined in the project's settings.

4) Initializing Database Connections: If the project uses a database, setup() sets up and configures the database connections based on the database settings defined in the project's settings.

5) Initializing Template Engine: If you're using Django's template system, setup() initializes the template engine and configures template-related settings.

6) Other Initialization Tasks: Apart from the tasks mentioned above, setup() handles other initialization tasks like setting up logging, loading translation catalogs, and more.

In most cases, as a developer, you don't need to explicitly call django.setup() yourself. It's automatically called by Django when you run management commands like runserver, migrate, or shell.
However, if you're writing custom scripts or tools outside of Django's management commands, you might need to call setup() before interacting with Django's components.

Keep in mind that the details of Django's internal workings might change with different versions of the framework, so it's a good practice to refer to the official documentation for the most accurate and up-to-date information.


===================================================================================================
Url configuration/mapping/routing
===================================================================================================
https://docs.djangoproject.com/en/4.2/topics/http/urls/#

Path converters
The following path converters are available by default:

str - Matches any non-empty string, excluding the path separator, '/'. This is the default if a converter isn’t included in the expression.
int - Matches zero or any positive integer. Returns an int.
slug - Matches any slug string consisting of ASCII letters or numbers, plus the hyphen and underscore characters. For example, building-your-1st-django-site.
uuid - Matches a formatted UUID. To prevent multiple URLs from mapping to the same page, dashes must be included and letters must be lowercase. For example, 075194d3-6885-417e-a8a8-6c931e272f00. Returns a UUID instance.
path - Matches any non-empty string, including the path separator, '/'. This allows you to match against a complete URL path rather than a segment of a URL path as with str.

**********************

Getting parameters:

path( 'index3/<int:id>', views.index3 , name="index3" ),
path( 'index4/<str:name>', views.index4 , name="index4" )

path('user/<int:id>', views.getUserById, name="getUser")

************

from django.http import  HttpResponse

def index3(request, id):
    return HttpResponse(f"hello world {id}")

def index4(request, name):
    return HttpResponse(f"hello world {name}")


def getUserById(request, id):
    user = User.objects.get(id=id)
    profile = {
        "name": user.username,
        "email":user.email
    }
    return JsonResponse(profile)


*****************************************
Passing extra options to view functions:

URLconfs have a hook that lets you pass extra arguments to your view functions, as a Python dictionary.
The path() function can take an optional third argument which should be a dictionary of extra keyword arguments to pass to the view function.

For example:

from django.urls import path
from . import views

urlpatterns = [
    path("blog/<int:year>/", views.year_archive, {"foo": "bar"}),
]

In this example, for a request to /blog/2005/, Django will call views.year_archive(request, year=2005, foo='bar').

This technique is used in the syndication framework to pass metadata and options to views.

Dealing with conflicts
It’s possible to have a URL pattern which captures named keyword arguments, and also passes arguments with the same names in its dictionary of extra arguments. When this happens, the arguments in the dictionary will be used instead of the arguments captured in the URL.

*****************************

Passing extra options to include():

Similarly, you can pass extra options to include() and each line in the included URLconf will be passed the extra options.

For example, these two URLconf sets are functionally identical:

Set one: ************

# main.py
from django.urls import include, path

urlpatterns = [
    path("blog/", include("inner"), {"blog_id": 3}),
]

# inner.py
from django.urls import path
from mysite import views

urlpatterns = [
    path("archive/", views.archive),
    path("about/", views.about),
]


Set two: ************

# main.py
from django.urls import include, path
from mysite import views

urlpatterns = [
    path("blog/", include("inner")),
]

# inner.py
from django.urls import path

urlpatterns = [
    path("archive/", views.archive, {"blog_id": 3}),
    path("about/", views.about, {"blog_id": 3}),
]


Note that extra options will always be passed to every line in the included URLconf, regardless of whether the line’s view actually accepts those options as valid. For this reason, this technique is only useful if you’re certain that every view in the included URLconf accepts the extra options you’re passing.

*******************************
other related topics:

1) reverse vs reverse_lazy
2) Namespacing URL names

see in polls app


===================================================================================================
Django Forms
===================================================================================================
https://docs.djangoproject.com/en/4.2/topics/forms/
https://docs.djangoproject.com/en/4.2/ref/forms/api/#ref-forms-api-configuring-label

The Form class:

forms.py
from django import forms

class NameForm(forms.Form):
    your_name = forms.CharField(label="Your name", max_length=100)


The whole form, when rendered for the first time, will look like:

<label for="your_name">Your name: </label>
<input id="your_name" type="text" name="your_name" maxlength="100" required>

Note that it does not include the <form> tags, or a submit button.
We’ll have to provide those ourselves in the template.

**************************
Bound and unbound form instances
The distinction between Bound and unbound forms is important:

An unbound form has no data associated with it. When rendered to the user, it will be empty or will contain default values.

A bound form has submitted data, and hence can be used to tell if that data is valid. If an invalid bound form is rendered, it can include inline error messages telling the user what data to correct.
The form’s is_bound attribute will tell you whether a form has data bound to it or not.

***************************
Widgets:

Each form field has a corresponding Widget class, which in turn corresponds to an HTML form widget such as <input type="text">.

In most cases, the field will have a sensible default widget.
For example:
By default, a CharField will have a TextInput widget, that produces an <input type="text"> in the HTML.
If you needed <textarea> instead, you’d specify the appropriate widget when defining your form field,
as we have done for the message field.

****************************
Form rendering options

There are other output options though for the <label>/<input> pairs:

{{ form.as_div }} will render them wrapped in <div> tags.
{{ form.as_table }} will render them as table cells wrapped in <tr> tags.
{{ form.as_p }} will render them wrapped in <p> tags.
{{ form.as_ul }} will render them wrapped in <li> tags.

Note that you’ll have to provide the surrounding <table> or <ul> elements yourself.

Here’s the output of {{ form.as_p }} for our ContactForm instance:

<p><label for="id_subject">Subject:</label>
    <input id="id_subject" type="text" name="subject" maxlength="100" required></p>
<p><label for="id_message">Message:</label>
    <textarea name="message" id="id_message" required></textarea></p>
<p><label for="id_sender">Sender:</label>
    <input type="email" name="sender" id="id_sender" required></p>
<p><label for="id_cc_myself">Cc myself:</label>
    <input type="checkbox" name="cc_myself" id="id_cc_myself"></p>
Note that each form field has an ID attribute set to id_<field-name>, which is referenced by the accompanying label tag. This is important in ensuring that forms are accessible to assistive technology such as screen reader software. You can also customize the way in which labels and ids are generated.

****************************

Useful attributes on {{ field }} include:

{{ field.errors }}
Outputs a <ul class="errorlist"> containing any validation errors corresponding to this field. You can customize the presentation of the errors with a {% for error in field.errors %} loop. In this case, each object in the loop is a string containing the error message.

{{ field.field }}
The Field instance from the form class that this BoundField wraps. You can use it to access Field attributes, e.g. {{ char_field.field.max_length }}.

{{ field.help_text }}
Any help text that has been associated with the field.

{{ field.html_name }}
The name of the field that will be used in the input element’s name field. This takes the form prefix into account, if it has been set.

{{ field.id_for_label }}
The ID that will be used for this field (id_email in the example above). If you are constructing the label manually, you may want to use this in lieu of label_tag. It’s also useful, for example, if you have some inline JavaScript and want to avoid hardcoding the field’s ID.

{{ field.is_hidden }}
This attribute is True if the form field is a hidden field and False otherwise. It’s not particularly useful as a template variable, but could be useful in conditional tests such as:
{% if field.is_hidden %}
   {# Do something special #}
{% endif %}

{{ field.label }}
The label of the field, e.g. Email address.

{{ field.label_tag }}
The field’s label wrapped in the appropriate HTML <label> tag. This includes the form’s label_suffix.
 For example, the default label_suffix is a colon:
<label for="id_email">Email address:</label>

{{ field.legend_tag }}
Similar to field.label_tag but uses a <legend> tag in place of <label>, for widgets with multiple inputs wrapped in a <fieldset>.

{{ field.value }}
The value of the field. e.g someone@example.com.

******************************************************************************************

Form initialization and validation process:

1) Form Initialization: When you create an instance of a form, such as form = MyForm(request.POST), the form's constructor initializes its fields and sets the initial data. However, the cleaned_data dictionary is not populated at this stage.

2) Form Validation: After initializing the form, you usually call the is_valid() method to trigger the validation process.
This process involves several steps:

    a) Field Cleaning: The clean() method of each field is called. This method handles field-specific cleaning logic, such as converting input values, validating formats, etc.
    The cleaned data for each field is temporarily stored in the field's cleaned() method until the entire form validation is complete.

    b) Custom Clean Methods: If you've defined custom clean methods in your form class (e.g., clean_<field_name>()), these methods are also called during the validation process.
    These methods can perform cross-field validation or more complex checks.

    c) Form Clean Method: If you've defined a clean() method in your form class (not to be confused with field-specific clean methods), it's called at the end of the validation process.
    This method can perform additional validation or checks that involve multiple fields.

3) Populating cleaned_data: Once the entire validation process is successfully completed (no validation errors were raised), the cleaned data for each field is collected and stored in the cleaned_data dictionary.
The keys in the dictionary are the field names, and the values are the cleaned and validated values of the respective fields.

After the validation process is finished and you've called is_valid() on the form, you can access the cleaned_data attribute to retrieve the cleaned values.
If any validation errors occurred during the process, they will be stored in the errors attribute of the form, and cleaned_data won't be populated for that field.

******************************************************************************************
The Forms API

https://docs.djangoproject.com/en/4.2/ref/forms/api/#module-django.forms

from my_forms.forms import ContactForm

>>> data = {
    "subject": "hello",
    "message": "Hi there",
    "sender": "foo@example.com",
    "cc_myself": True,
}

>>> f = ContactForm(data)

>>> f = ContactForm()
>>> f.is_bound
False

>>> f = ContactForm({"subject": "hello"})
>>> f.is_bound
True

Note that passing an empty dictionary creates a bound form with empty data:

>>> f = ContactForm({})
>>> f.is_bound
True

If you have a bound Form instance and want to change the data somehow,
or if you want to bind an unbound Form instance to some data,
create another Form instance. There is no way to change data in a Form instance.
Once a Form instance has been created, you should consider its data immutable, whether it has data or not.
************************

Using forms to validate data

>>> f.is_valid()

Let’s try with some invalid data:

>>> data = {
    "subject": "",
    "message": "Hi there",
    "sender": "invalid email address",
    "cc_myself": True,
}
>>> f = ContactForm(data)
>>> f.is_valid()
False
************************

Form.errors:
Access the errors attribute to get a dictionary of error messages:

>>> f.errors
{'sender': ['Enter a valid email address.'], 'subject': ['This field is required.']}
In this dictionary, the keys are the field names, and the values are lists of strings representing the error messages. The error messages are stored in lists because a field can have multiple error messages.

You can access errors without having to call is_valid() first.
The form’s data will be validated the first time either you call is_valid() or access errors.

************************

Form.errors.as_data()
Returns a dict that maps fields to their original ValidationError instances.

f.errors.as_data()
{'subject': [ValidationError(['This field is required.'])], 'sender': [ValidationError(['Enter a valid email address.'])]}

************************

Form.errors.as_json(escape_html=False):
Returns the errors serialized as JSON.

>>> f.errors.as_json()
'{"subject": [{"message": "This field is required.", "code": "required"}], "sender": [{"message": "Enter a valid email address.", "code": "invalid"}]}'

1) escape_html=False:
By default, when you use as_json(), it does not escape its output.
Escaping means converting characters that have special meaning in HTML, like <, >, and &, into their HTML entity equivalents (e.g., &lt;, &gt;, &amp;).
If you're using the JSON output in contexts like AJAX requests, where the client interprets the response and inserts errors into the page,
 you need to ensure that you properly escape the JSON on the client-side to prevent cross-site scripting (XSS) attacks.

For example, when adding the JSON error messages to the page using JavaScript, you should set the error text as text content (element.textContent = errorText) rather than HTML content (element.innerHTML = errorText),
which can help prevent unintentional script execution.

2) escape_html=True:
If you want to use the error messages directly in HTML without manual escaping on the client-side, you can set escape_html=True.
 This will cause the error messages to be escaped within the JSON, making them safe for direct insertion into HTML content.

Note:
If you plan to use this JSON in a web page context, it's important to handle escaping properly to prevent security vulnerabilities.

***********************
Form.errors.get_json_data(escape_html=False):

Returns the errors as a dictionary suitable for serializing to JSON.
Form.errors.as_json() returns serialized JSON, while this returns the error data before it’s serialized.

The escape_html parameter behaves as described in Form.errors.as_json().

>>> f.errors.get_json_data()
{'subject': [{'message': 'This field is required.', 'code': 'required'}], 'sender': [{'message': 'Enter a valid email address.', 'code': 'invalid'}]}

The main use case for get_json_data() is when you need more control over how the error data is processed and serialized before being converted to JSON.
 This can be helpful if you want to apply additional logic or transformation to the error data before rendering it as JSON.

For example:
def my_view(request):
    if request.method == 'POST':
        form = MyForm(request.POST)
        if not form.is_valid():
            # Retrieve error data as a dictionary
            error_data = form.errors.get_json_data()
            # Perform additional processing or manipulation if needed
            processed_error_data = my_custom_process_function(error_data)
            # Convert processed error data to JSON
            json_error_data = json.dumps(processed_error_data)
            return HttpResponse(json_error_data, content_type='application/json')
    else:
        form = MyForm()
    return render(request, 'my_template.html', {'form': form})

**************************

Form.add_error(field, error):

This method allows adding errors to specific fields from within the Form.clean() method, or from outside the form altogether; for instance from a view.

The field argument is the name of the field to which the errors should be added. If its value is None the error will be treated as a non-field error as returned by Form.non_field_errors().

The error argument can be a string, or preferably an instance of ValidationError. See Raising ValidationError for best practices when defining form errors.

Note that Form.add_error() automatically removes the relevant field from cleaned_data.

Example:
1)

>>> f.cleaned_data
{'message': 'Hi there', 'cc_myself': True}
>>> f.add_error('message', "Message is too short")
>>> f.cleaned_data
{'cc_myself': True}
>>> f.errors
{'subject': ['This field is required.'], 'sender': ['Enter a valid email address.'], 'message': ['Message is too short']}

2)

from django import forms

class EmailForm(forms.Form):
    email = forms.EmailField()

    def clean_email(self):
        email = self.cleaned_data.get('email')
        if email and 'example.com' not in email:
            self.add_error('email', "Email must be from example.com domain")
        return email

*********************
Form.has_error(field, code=None):

This method returns a boolean designating whether a field has an error with a specific error code.
If code is None, it will return True if the field contains any errors at all.

To check for non-field errors use NON_FIELD_ERRORS as the field parameter.

>>> f.has_error('subject')
True

*********************

Form.non_field_errors():

This method returns the list of errors from Form.errors that aren’t associated with a particular field.
This includes ValidationErrors that are raised in Form.clean() and errors added using Form.add_error(None, "...").

>>> f.non_field_errors()

*********************
Behavior of unbound forms:

It’s meaningless to validate a form with no data, but, for the record, here’s what happens with unbound forms:

>>> f = ContactForm()
>>> f.is_valid()
False
>>> f.errors
{}

************************************************************************************
Initial form values:

Form.initial:
Use initial to declare the initial value of form fields at runtime.
For example, you might want to fill in a username field with the username of the current session.

To accomplish this, use the initial argument to a Form. This argument, if given, should be a dictionary mapping field names to initial values.
Only include the fields for which you’re specifying an initial value; it’s not necessary to include every field in your form.

For example:

>>> f = ContactForm(initial={"subject": "Hi there!"})
These values are only displayed for unbound forms, and they’re not used as fallback values if a particular value isn’t provided.

If a Field defines initial and you include initial when instantiating the Form, then the latter initial will have precedence.
In this example, initial is provided both at the field level and at the form instance level, and the latter gets precedence:

>>> from django import forms
>>> class CommentForm(forms.Form):
...     name = forms.CharField(initial="class")
...     url = forms.URLField()
...     comment = forms.CharField()
...
>>> f = CommentForm(initial={"name": "instance"}, auto_id=False)
>>> print(f)
<tr><th>Name:</th><td><input type="text" name="name" value="instance" required></td></tr>
<tr><th>Url:</th><td><input type="url" name="url" required></td></tr>
<tr><th>Comment:</th><td><input type="text" name="comment" required></td></tr>

*********************

Form.get_initial_for_field(field, field_name):

Returns the initial data for a form field.
It retrieves the data from Form.initial if present, otherwise trying Field.initial.
Callable values are evaluated.

>>> f.get_initial_for_field(f.fields["subject"], "subject")
'Hi there!'


************************************************************************************
Checking which form data has changed:

Form.has_changed()¶
Use the has_changed() method on your Form when you need to check if the form data has been changed from the initial data.

>>> data = {'subject': 'hello',
    'message': 'Hi there',
    'sender': 'foo@example.com',
    'cc_myself': True
}
>>> f = ContactForm(data, initial=data)
>>> f.has_changed()
False

When the form is submitted, we reconstruct it and provide the original data so that the comparison can be done:
>>> f = ContactForm(request.POST, initial=data)
>>> f.has_changed()

has_changed() will be True if the data from request.POST differs from what was provided in initial or False otherwise.
The result is computed by calling Field.has_changed() for each field in the form.

*************************

Form.changed_data:
The changed_data attribute returns a list of the names of the fields whose values in the form’s bound data (usually request.POST) differ from what was provided in initial. It returns an empty list if no data differs.

>>> f = ContactForm(request.POST, initial=data)
>>> if f.has_changed():
...     print("The following fields changed: %s" % ", ".join(f.changed_data))
>>> f.changed_data
['subject', 'message']

******************************************************************************************
Accessing the fields from the form¶

Form.fields:

>>> for row in f.fields.values():
...     print(row)
...
<django.forms.fields.CharField object at 0x7ffaac632510>
<django.forms.fields.URLField object at 0x7ffaac632f90>
<django.forms.fields.CharField object at 0x7ffaac3aa050>

>>> f.fields["name"]
<django.forms.fields.CharField object at 0x7ffaac6324d0>

You can alter the field and BoundField of Form instance to change the way it is presented in the form:

>>> f.as_div().split("</div>")[0]
'<div><label for="id_subject">Subject:</label><input type="text" name="subject" maxlength="100" required id="id_subject">'

>>> f["subject"].label = "Topic"

>>> f.as_div().split("</div>")[0]
'<div><label for="id_subject">Topic:</label><input type="text" name="subject" maxlength="100" required id="id_subject">'

***********************
f.base_fields vs  f.fields

Both f.base_fields and f.fields provide information about the fields in a form,
the key difference is that f.base_fields contains the original field instances defined in the form class,
while f.fields represents the fields that will be displayed on the current form instance, considering any dynamic modifications you've made.

******************************************************************************************
Accessing “clean” data:

Form.cleaned_data:
Each field in a Form class is responsible not only for validating data, but also for “cleaning” it – normalizing it to a consistent format.
This is a nice feature, because it allows data for a particular field to be input in a variety of ways, always resulting in consistent output.

For example, DateField normalizes input into a Python datetime.date object. Regardless of whether you pass it a string in the format '1994-07-15', a datetime.date object, or a number of other formats, DateField will always normalize it to a datetime.date object as long as it’s valid.

Once you’ve created a Form instance with a set of data and validated it, you can access the clean data via its cleaned_data attribute:

>>> data = {
...     "subject": "hello",
...     "message": "Hi there",
...     "sender": "foo@example.com",
...     "cc_myself": True,
... }
>>> f = ContactForm(data)
>>> f.is_valid()
True
>>> f.cleaned_data
{'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'}

Note that any text-based field – such as CharField or EmailField – always cleans the input into a string.

If your data does not validate, the cleaned_data dictionary contains only the valid fields:

************************
cleaned_data will always only contain a key for fields defined in the Form,
even if you pass extra data when you define the Form.
In this example, we pass a bunch of extra fields to the ContactForm constructor, but cleaned_data contains only the form’s fields:

>>> data = {
...     "subject": "hello",
...     "message": "Hi there",
...     "sender": "foo@example.com",
...     "cc_myself": True,
...     "extra_field_1": "foo",
...     "extra_field_2": "bar",
...     "extra_field_3": "baz",
... }
>>> f = ContactForm(data)
>>> f.is_valid()
True
>>> f.cleaned_data  # Doesn't contain extra_field_1, etc.
{'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'}

************************
When the Form is valid, cleaned_data will include a key and value for all its fields,
even if the data didn’t include a value for some optional fields.

In this example, the data dictionary doesn’t include a value for the nick_name field,
but cleaned_data includes it, with an empty value:

>>> from django import forms
>>> class OptionalPersonForm(forms.Form):
...     first_name = forms.CharField()
...     last_name = forms.CharField()
...     nick_name = forms.CharField(required=False)
...
>>> data = {"first_name": "John", "last_name": "Lennon"}
>>> f = OptionalPersonForm(data)
>>> f.is_valid()
True
>>> f.cleaned_data
{'nick_name': '', 'first_name': 'John', 'last_name': 'Lennon'}

In this above example, the cleaned_data value for nick_name is set to an empty string, because nick_name is CharField, and CharFields treat empty values as an empty string.
Each field type knows what its “blank” value is – e.g., for DateField, it’s None instead of the empty string.
For full details on each field’s behavior in this case, see the “Empty value” note for each field in the “Built-in Field classes” section below.

You can write code to perform validation for particular form fields (based on their name) or for the form as a whole (considering combinations of various fields). More information about this is in Form and field validation.

******************************************************************************************
Configuring form elements’ HTML id attributes and <label> tags¶

Form.auto_id:

By default, the form rendering methods include:

1) HTML id attributes on the form elements. The id attribute values are generated by prepending id_ to the form field names
2) The corresponding <label> tags around the labels. An HTML <label> tag designates which label text is associated with which form element. This small enhancement makes forms more usable and more accessible to assistive devices. It’s always a good idea to use <label> tags.

>>> f = ContactForm(auto_id=False)
>>> print(f.as_div())
<div>Subject:<input type="text" name="subject" maxlength="100" required></div>
<div>Message:<textarea name="message" cols="40" rows="10" required></textarea></div>
<div>Sender:<input type="email" name="sender" required></div>
<div>Cc myself:<input type="checkbox" name="cc_myself"></div>
****************

If auto_id is set to True, then the form output will include <label> tags and will use the field name as its id for each form field:

>>> f = ContactForm(auto_id=True)
>>> print(f.as_div())
<div><label for="subject">Subject:</label><input type="text" name="subject" maxlength="100" required id="subject"></div>
<div><label for="message">Message:</label><textarea name="message" cols="40" rows="10" required id="message"></textarea></div>
<div><label for="sender">Sender:</label><input type="email" name="sender" required id="sender"></div>
<div><label for="cc_myself">Cc myself:</label><input type="checkbox" name="cc_myself" id="cc_myself"></div>

****************
If auto_id is set to a string containing the format character '%s', then the form output will include <label> tags,
and will generate id attributes based on the format string.

For example, for a format string 'field_%s', a field named subject will get the id value 'field_subject'. Continuing our example:

>>> f = ContactForm(auto_id="id_for_%s")
>>> print(f.as_div())
<div><label for="id_for_subject">Subject:</label><input type="text" name="subject" maxlength="100" required id="id_for_subject"></div>
<div><label for="id_for_message">Message:</label><textarea name="message" cols="40" rows="10" required id="id_for_message"></textarea></div>
<div><label for="id_for_sender">Sender:</label><input type="email" name="sender" required id="id_for_sender"></div>
<div><label for="id_for_cc_myself">Cc myself:</label><input type="checkbox" name="cc_myself" id="id_for_cc_myself"></div>

By default, auto_id is set to the string 'id_%s'.

*****************************************
Form.label_suffix:

A translatable string (defaults to a colon (:) in English) that will be appended after any label name when a form is rendered.

It’s possible to customize that character, or omit it entirely, using the label_suffix parameter:

>>> f = ContactForm(auto_id="id_for_%s", label_suffix="")
>>> print(f.as_div())
<div><label for="id_for_subject">Subject</label><input type="text" name="subject" maxlength="100" required id="id_for_subject"></div>
<div><label for="id_for_message">Message</label><textarea name="message" cols="40" rows="10" required id="id_for_message"></textarea></div>
<div><label for="id_for_sender">Sender</label><input type="email" name="sender" required id="id_for_sender"></div>
<div><label for="id_for_cc_myself">Cc myself</label><input type="checkbox" name="cc_myself" id="id_for_cc_myself"></div>

>>> f = ContactForm(auto_id="id_for_%s", label_suffix=" ->")
>>> print(f.as_div())
<div><label for="id_for_subject">Subject -&gt;</label><input type="text" name="subject" maxlength="100" required id="id_for_subject"></div>
<div><label for="id_for_message">Message -&gt;</label><textarea name="message" cols="40" rows="10" required id="id_for_message"></textarea></div>
<div><label for="id_for_sender">Sender -&gt;</label><input type="email" name="sender" required id="id_for_sender"></div>
<div><label for="id_for_cc_myself">Cc myself -&gt;</label><input type="checkbox" name="cc_myself" id="id_for_cc_myself"></div>

Note that the label suffix is added only if the last character of the label isn’t a punctuation character (in English, those are ., !, ? or :).

Fields can also define their own label_suffix. This will take precedence over Form.label_suffix.
The suffix can also be overridden at runtime using the label_suffix parameter to label_tag()/ legend_tag().

***************************************************

Form.use_required_attribute¶

It controls whether the HTML attribute required is added to form fields marked as required in the form.
When set to True(the default), the required attribute is added to the HTML input elements, which prompts browsers to enforce client-side validation on those fields.

This will remove required attribute from the fields (i.e.remove frontend validations)
>>> f = ContactForm(use_required_attribute=False)
>>> print(f)
******************************************************************************************
Outputting forms as HTML¶

There are other output options though for the <label>/<input> pairs:

{{ form.as_div }} will render them wrapped in <div> tags.
{{ form.as_table }} will render them as table cells wrapped in <tr> tags.
{{ form.as_p }} will render them wrapped in <p> tags.
{{ form.as_ul }} will render them wrapped in <li> tags.

******************************************************************************************

More granular output¶

class BoundField¶
Used to display HTML or access attributes for a single field of a Form instance.
The __str__() method of this object displays the HTML for this field.

To retrieve a single BoundField, use dictionary lookup syntax on your form using the field’s name as the key:

>>> form = ContactForm()
>>> print(form["subject"])
<input id="id_subject" type="text" name="subject" maxlength="100" required>

To retrieve all BoundField objects, iterate the form:
>>> form = ContactForm()
>>> for boundfield in form:
    print(boundfield)
**************************

Attributes of BoundField¶

>>> form = ContactForm(initial={"subject":"initial subject"})
>>> form["subject"].initial
>>> form["subject"].data
>>> form["subject"].errors
>>> form["subject"].field
>>> form["subject"].help_text
>>> form["subject"].html_name
>>> form["subject"].id_for_label
>>> form["subject"].label
>>> form["subject"].name
>>> form["subject"].css_classes()
>>> form["subject"].value()

Usage example:

from django import forms

class FeedbackForm(forms.Form):
    subject = forms.CharField(max_length=100, label="Subject:")
    message = forms.CharField(widget=forms.Textarea, label="Message:")
    sender = forms.EmailField(label="Your Email:")
    cc_myself = forms.BooleanField(required=False, label="Send me a copy")

# Assume that this is a view function that handles form submissions

def submit_feedback(request):
    if request.method == 'POST':
        form = FeedbackForm(request.POST)
        if form.is_valid():
            # Process the form data
            subject = form.cleaned_data['subject']
            message = form.cleaned_data['message']
            sender = form.cleaned_data['sender']
            cc_myself = form.cleaned_data['cc_myself']

            # Perform further actions like sending emails, saving to database, etc.
            # ...
    else:
        form = FeedbackForm(initial={"subject": "Initial subject"})

    return render(request, 'feedback.html', {'form': form})


# feedback.html:
<form method="post">
    {% csrf_token %}

    <!-- Custom rendering using attributes and methods -->
    <label for="{{ form.subject.id_for_label }}">{{ form.subject.label }}</label>
    <input type="text" name="{{ form.subject.name }}" id="{{ form.subject.id_for_label }}"
           class="{{ form.subject.css_classes }}" value="{{ form.subject.value }}">
    <span class="help-text">{{ form.subject.help_text }}</span>
    <ul class="error-list">
        {% for error in form.subject.errors %}
            <li>{{ error }}</li>
        {% endfor %}
    </ul>

    <!-- ... Repeat the above pattern for other fields ... -->

    <button type="submit">Submit</button>
</form>

*************************************

form.fields['field_name'].initial   vs   form.field_name.initial

In Django templates, you can access form fields using the syntax form.field_name,
and this is possible because the template system provides a context that includes the form object and its fields.

However, when you're working in Python code, such as in the Python shell or a Django view function,
you don't have direct access to form fields using the form.field_name syntax.
Instead, you interact with form fields using their names as keys to access their data, initial values, and more.
This is because the context in Python code is different from the context provided by the Django template system.


******************************************************************************************

All methods on form instance:

f.add_error(              f.as_ul(                  f.data                    f.field_order             f.has_changed(            f.is_valid(               f.render(                 f.template_name_table
f.add_initial_prefix(     f.auto_id                 f.declared_fields         f.fields                  f.has_error(              f.label_suffix            f.renderer                f.template_name_ul
f.add_prefix(             f.base_fields             f.default_renderer        f.files                   f.hidden_fields(          f.media                   f.template_name           f.use_required_attribute
f.as_div(                 f.changed_data            f.empty_permitted         f.full_clean(             f.initial                 f.non_field_errors(       f.template_name_div       f.visible_fields(
f.as_p(                   f.clean(                  f.error_class(            f.get_context(            f.is_bound                f.order_fields(           f.template_name_label
f.as_table(               f.cleaned_data            f.errors                  f.get_initial_for_field(  f.is_multipart(           f.prefix                  f.template_name_p
>>> f.



===================================================================================================
Authentication and Authorization
===================================================================================================
Authentication and authorization are two fundamental concepts in computer security and access control.
Authentication and authorization work together to create a layered security approach.
Authentication ensures that only legitimate users gain access to a system,
while authorization ensures that authenticated users have appropriate access rights.
Implementing strong authentication and authorization practices is essential for protecting sensitive data, preventing unauthorized access, and maintaining the overall security of a system or application.


Authentication:
Authentication is the process of verifying the identity of a user, system, or entity. It ensures that the entity claiming a particular identity is indeed who it claims to be.
Authentication mechanisms are used to prevent unauthorized access and ensure that only legitimate users can access resources or perform actions within a system.

There are several methods of authentication, including:

1) Username and Password: This is the most common method where users provide a unique username and a secret password.
2) Multi-Factor Authentication (MFA): In addition to a password, another piece of evidence is required, such as a one-time code sent to a mobile device.
3) Biometric Authentication: This includes fingerprint scans, facial recognition, and other physiological characteristics to verify identity.
4) Token-based Authentication: Users are provided with a token or key that is used as proof of identity.
5) Certificate-based Authentication: Digital certificates are used to authenticate users or systems.

*************************

Authorization:

Authorization, on the other hand, comes after authentication and involves determining what actions or resources a user is allowed to access after their identity has been verified. Authorization ensures that authenticated users have appropriate permissions to perform specific actions or access certain resources within a system. It defines the scope of a user's privileges and controls what they can and cannot do. Authorization can be implemented through role-based access control (RBAC) or attribute-based access control (ABAC), among other methods.

2) Role-Based Access Control (RBAC): Users are assigned roles, and these roles have specific permissions associated with them. Users can perform actions based on their assigned roles.
3) Attribute-Based Access Control (ABAC):
Access decisions are made based on attributes associated with users, resources, and the environment.
It provides more fine-grained control over access.

Example for ABAC:

Scenario: File-Sharing System

Imagine a file-sharing system where users can upload and access various files.
 The system uses ABAC to control access to files based on attributes such as user roles, file types, and sensitivity levels.

Attributes:
Role: Users can have roles such as "Employee" and "Manager."
File Type: Files can be categorized as "Documents," "Spreadsheets," or "Presentations."
Sensitivity Level: Files are assigned sensitivity levels: "Low," "Medium," and "High."

Attribute-Based Access Control Rules:
Access to Files:
    Employees can access "Documents" and "Spreadsheets" files.
    Managers can access all types of files.
Sensitive Files:
    Only users with a sensitivity level of "High" can access files marked as "High" sensitivity.

Example Scenarios:

Jane, an employee, wants to access a presentation file. The ABAC system checks her role ("Employee") and the file type ("Presentation"). Since she has the appropriate role for the file type, she's granted access.
Alex, a manager, tries to access a spreadsheet. The ABAC system checks his role ("Manager") and the file type ("Spreadsheet"), so he's allowed to access the file.
Lisa, an employee, attempts to access a "High" sensitivity document. The ABAC system checks her role ("Employee") and the sensitivity level of the file ("High"). Since her sensitivity level doesn't match the requirement, access is denied.
Mark, a manager, needs to access a "High" sensitivity presentation. The ABAC system verifies his role ("Manager") and the sensitivity level of the file ("High"), granting him access.

In this simple example, ABAC is used to control access to files based on attributes like roles, file types, and sensitivity levels. Access control decisions are made dynamically based on the attributes associated with the user and the resources they're trying to access. This example illustrates how ABAC can provide fine-grained control over access, allowing for more flexible and context-aware authorization decisions.

**************************************************
Authentication in web requests
**************************************************

Authentication in web requests is a process by which a client (usually a user or another system) provides credentials to a server to prove its identity. This is essential for ensuring that only authorized users or systems can access specific resources or perform actions on a web application. There are several common methods of implementing authentication in web requests:

Basic Authentication:
Basic authentication is a simple method where the client includes a username and password in the HTTP request headers. The credentials are usually base64-encoded for transmission, although it's important to note that this encoding doesn't provide strong security on its own. Basic authentication is often used with HTTPS to encrypt the credentials during transmission.

Example of headers:
Authorization: Basic base64(username:password)
*****************

Digest Authentication:
Digest authentication is a more secure alternative to basic authentication. It involves the server challenging the client with a nonce value that the client combines with the username, password, and other data to produce a hash. This hash is sent back to the server for verification. Digest authentication helps prevent sending plain-text passwords over the network.
*****************

Token-Based Authentication:
Token-based authentication involves the use of tokens instead of sending credentials with each request. After successful login, the server provides the client with a token that the client includes in the headers of subsequent requests. This token is often digitally signed to prevent tampering. Token-based authentication is commonly used in modern web applications and APIs.

Example of headers:
Authorization: Bearer <token>

*****************

OAuth and OAuth2:
OAuth (Open Authorization) and OAuth2 are authentication and authorization protocols that allow a user to grant limited access to their resources on one site to another site without exposing their credentials. OAuth2, the newer version, is widely used for granting access to third-party applications or services. It involves obtaining an access token after user consent and using that token for making authorized API requests.

*****************
JWT (JSON Web Tokens):
JWT is a compact, URL-safe means of representing claims between two parties. It's often used as a token format for token-based authentication. A JWT contains encoded information (claims) that can include user identity, expiration time, and other metadata. The server signs the JWT, and the client includes it in headers to authenticate and access protected resources.

These authentication methods help secure web requests by verifying the identity of clients and ensuring that only authorized users or systems can interact with a web application's resources. The choice of authentication method depends on factors such as security requirements, ease of implementation, and the specific use case of the web application.






===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================

