Topics:

https://docs.djangoproject.com/en/4.2/ref/


https://docs.djangoproject.com/en/4.2/contents/

https://docs.djangoproject.com/en/4.2/topics/

***************************
frequently used commands
***************************

1) reload shell:
exit()
python manage.py shell
from my_models.models import *
from many_to_many_relationship.models import *
from many_to_one_relationship.models import *

2) migrate:
python manage.py makemigrations
python manage.py migrate


**********************************
Day 1:
Models
**********************************

Create app inside project:

1) python manage.py startapp name_of_app

python manage.py startapp my_models

2) Register app in installed_app in settings.py file:
INSTALLED_APPS = [
    # ...
    'my_models.apps.MyModelsConfig',
    # ...
]

3) Add urls of the app in main urls.py:

a) create urls.py file in app.
b) register this url file in main urls.py:
    from django.contrib import admin
    from django.urls import path, include

    urlpatterns = [
        path('admin/', admin.site.urls),
        path('', include('blog.urls')),
    ]

4) add model in current app's admin.py file:
from django.contrib import admin
from .models import Person

admin.site.register(Person)


**********************************
naming convention for apps:

Here are a few examples of app names following the convention:

blog (for a blogging app)
ecommerce (for an e-commerce app)
user_profile (for a user profile app)
inventory_management (for an inventory management app)
event_calendar (for an event calendar app)

**********************************

Add Simple model:

1) Add model in model.p

from django.db import models

class User(models.Model):
    name = models.CharField(max_length=128)
    email = models.CharField(max_length=128)

Run the Migrations commands in order to get changes to our database.

2) python manage.py makemigrations

3) python manage.py sqlmigrate my_models 0001   #  it prints out the code that is going to run

4) python manage.py migrate

**********************************

Manipulate database

Start the django shell:

python manage.py shell

(In the shell at the prompt)

from my_models.models import User

u = User(name='Kristen', email='kf@umich.edu')
u.save()
u = User(name='Chuck', email='csev@umich.edu')
u.save()
u = User(name='Colleen', email='cvl@umich.edu')
u.save()
u = User(name='Ted', email='ted@umich.edu')
u.save()
u = User(name='Sally', email='a2@umich.edu')
u.save()

User.objects.values()
User.objects.filter(email='csev@umich.edu').values()

User.objects.filter(email='ted@umich.edu').delete()
User.objects.values()

User.objects.filter(email='csev@umich.edu').update(name='Charles')
User.objects.values()

User.objects.values().order_by('email')
User.objects.values().order_by('-name')

quit()


**********************************
one to many relationship:
**********************************

class Artist(models.Model):
    name = models.CharField(max_length=200, db_index=True, help_text='Artist name')

    def __str__(self):
        """String for representing the Model object."""
        return self.name

class Album(models.Model):
    title = models.CharField(max_length=200, db_index=True, help_text='Album title')
    artist = models.ForeignKey('Artist', on_delete=models.SET_NULL, null=True)

    def __str__(self):
        """String for representing the Model object."""
        return self.title

class Genre(models.Model):
    name = models.CharField(max_length=200, db_index=True, help_text='Genre of music (i.e. Blues)')

    def __str__(self):
        """String for representing the Model object."""
        return self.name

class Track(models.Model):
    title = models.CharField(max_length=200, db_index=True, help_text='Track title')
    rating = models.IntegerField(null=True)
    length = models.IntegerField(null=True)
    count = models.IntegerField(null=True)
    album = models.ForeignKey('Album', on_delete=models.CASCADE)
    genre = models.ForeignKey('Genre', on_delete=models.SET_NULL, null=True)

    def __str__(self):
        """String for representing the Model object."""
        return self.title


Adding data:
from my_models.models import Artist, Genre, Album, Track;

zep = Artist(name='Led Zepplin')
zep.save()
zep.id

abc = Artist(name='ACDC')
abc.save()

Artist.objects.values()

made = Album(title='Who Made Who', artist=abc)
made.save()
zep_iv = Album(title='IV', artist=zep)
zep_iv.save()
zep_v = Album(title='V', artist=zep)
zep_v.save()

ROCK = Genre(name='Rock')
ROCK.save()
met = Genre(name='Metal')
met.save()

x = Track(title='Black Dog', rating=5, length=297, count=9, album=zep_iv, genre=ROCK)
x.save()
x.id

x = Track(title='Stairway', rating=5, length=482, count=0, album=zep_iv, genre=ROCK)
x.save()
x.id

x = Track(title='About to Rock', rating=5, length=313, count=0, album=made, genre=met)
x.save()
x = Track(title='Who Made Who', rating=5, length=207, count=0, album=made, genre=met)
x.save()

Track.objects.values()

first = Track.objects.get(pk=1)
first

print(first)

print(first.genre)

print(first.genre.name)

print(first.album)

print(first.album.artist)

x = Artist.objects.get(pk=1)
x.album_set.values()

******************

each person has many accounts:

p1 = Person(name="Joan louji", email="sjlouji10@gmail.com", mobile="123412")
p1.save()

a1 = Account(person=p1, balance="1002335", account_number="432198176354")
a1.save()
a2 = Account(person=p1, balance="1002", account_number="4321981763541234")
a2.save()
a3 = Account(person=p1, balance="103412", account_number="43219813254")
a3.save()

p1.account_set.values()

**********************************
# One to One Relationship
**********************************

One to One Relationship
In this type of relationship, both tables can only have one record on either side of the relationship.
For example,
let’s consider two entities person(person_id, person_name)
and adhar(adhar_id, adhar_details). Here, a person can have only one Adhar ID and an Ahdar can be related to only one person.


# https://sjlouji10.medium.com/django-models-with-relationships-one-to-one-relationship-f3ef8d77aec1

class Person(models.Model):
    name = models.TextField(max_length=100)
    email = models.EmailField()
    mobile = models.TextField(max_length=100)


class Adhar(models.Model):
    person = models.OneToOneField("Person", on_delete=models.CASCADE)
    signature = models.TextField()
    adhar_no = models.TextField(max_length=100)


Add data:
from my_models.models import Person, Adhar

p1 = Person(name="Joan louji", email="sjlouji10@gmail.com", mobile="123412")
p1.save()
p2 = Person(name="Rion", email="rion@gmail.com", mobile="0987632")
p2.save()

a1 = Adhar(person=p1, signature="asdf234dsafuiq3&^$^GUJHVR", adhar_no="432198176354")
a1.save()
a2 = Adhar(person=p2, signature="adfpoiwruywqtrgmnb13241)*&^%$", adhar_no="2314928376")
a2.save()

p = Person.objects.all()
print(p)
<QuerySet [<Person: Person object (1)>, <Person: Person object (2)>]>

a = Adhar.objects.all()
print(a)
<QuerySet [<Adhar: Adhar object (1)>, <Adhar: Adhar object (2)>]>
a.values()
<QuerySet [{'id': 1, 'person_id': 1, 'signature': 'asdf234dsafuiq3&^$^GUJHVR', 'adhar_no': '432198176354'}, {'id': 2, 'person_id': 2, 'signature': 'adfpoiwruywqtrgmnb13241)*&^%$', 'adhar_no': '2314928376'}]>

Test one to one:
a3 = Adhar(person=p1, signature="asdf234dsafuiq3&^$^GUjkJHVR", adhar_no="4321982176354")
a3.save()

this will give error ->
    django.db.utils.IntegrityError: UNIQUE constraint failed: my_models_adhar.person_id

because
    person = models.OneToOneField("Person", on_delete=models.CASCADE)
makes
    "person_id" bigint NOT NULL UNIQUE


**********************************
Many to Many Relationship
**********************************

In this type of relationship, each record of the first table is related to many records of the second table and
also each record of the second table is related to many records of the first table.


class Customer(models.Model):
    cus_name = models.TextField(max_length=100)
    cus_email = models.EmailField()
    cus_mobile = models.TextField(max_length=100)

class Products(models.Model):
    cus_id = models.ManyToManyField("Customer")
    cus_name = models.TextField()
    cus_qty = models.TextField(max_length=100)

Add Data:

from my_models.models import Customer, Products

c1 = Customer(cus_name="Joan Louji", cus_email="sjlouji10@gmail.com", cus_mobile="927347234")
c1.save()
c2 = Customer(cus_name="Rion Louji", cus_email="sjlouji@gmail.com", cus_mobile="4327347234")
c2.save()
c3 = Customer(cus_name="Louji", cus_email="joanlouji@gmail.com", cus_mobile="4323417234")
c3.save()

p1 = Products(cus_name="Iphone", cus_qty="3")
p1.save()

p1.cus_id.add(c1)
p1.cus_id.add(c2)
p1.cus_id.add(c3)
p1.save()

cus = Customer.objects.all()
pro = Products.objects.all()

cus.values()
<QuerySet [{'id': 1, 'cus_name': 'Joan Louji', 'cus_email': 'sjlouji10@gmail.com', 'cus_mobile': '927347234'}, {'id': 2, 'cus_name': 'Rion Louji', 'cus_email': 'sjlouji@gmail.com', 'cus_mobile': '4327347234'}, {'id': 3, 'cus_name': 'Louji', 'cus_email': 'joanlouji@gmail.com', 'cus_mobile': '4323417234'}]>

p1.cus_id.all().values()
<QuerySet [{'id': 1, 'cus_name': 'Joan Louji', 'cus_email': 'sjlouji10@gmail.com', 'cus_mobile': '927347234'}, {'id': 2, 'cus_name': 'Rion Louji', 'cus_email': 'sjlouji@gmail.com', 'cus_mobile': '4327347234'}, {'id': 3, 'cus_name': 'Louji', 'cus_email': 'joanlouji@gmail.com', 'cus_mobile': '4323417234'}]>

************************



python manage.py startapp many_to_one_relationship
python manage.py startapp one_to_one_relationship
python manage.py startapp many_to_many_relationship



*************************

debugging:

import pdb; pdb.set_trace()

*************************

diff ways of getting sql in shell:

1) paster in shell:

import logging
log = logging.getLogger('django.db.backends')
log.setLevel(logging.DEBUG)
log.addHandler(logging.StreamHandler())

2) for simple logs add this code to settings.py file:

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'DEBUG',  # Set this to the desired logging level
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'level': 'DEBUG',  # Set this to the desired logging level
            'propagate': False,
        },
    },
}

3) add this code to settings.py for formatted sql:

import sqlparse
import logging

class SqlFormatter(logging.Formatter):
    def format(self, record):
        statement = record.getMessage()
        formatted_statement = sqlparse.format(statement, reindent=True)
        return formatted_statement


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'sql',  # Use the 'sql' formatter for SQL queries
        },
    },
    'formatters': {
        'sql': {
            '()': SqlFormatter,  # Use the full path to your custom formatter class
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'DEBUG',  # Set this to the desired logging level
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'level': 'DEBUG',  # Set this to the desired logging level
            'propagate': False,
        },
    },
}

4) If you're in the shell, or anywhere for that matter, you can use the queryset method

query.as_sql()
to print the SQL command.

ie:

MyModel.objects.all().query.as_sql()


**************************************************************************
https://docs.djangoproject.com/en/4.2/ref/models/fields/#field-options

Field options

NULL vs BLANK


null:
The null option is used at the database level and determines whether a field can store a NULL value in the database.
It's relevant for database columns.

If you set null=True on a field, it means that the field's database column can hold a NULL value, indicating the absence of data.
If you set null=False (which is the default), it means that the field cannot hold NULL values.

Example:

class MyModel(models.Model):
    some_field = models.CharField(max_length=50, null=True)

In this example, some_field can store NULL values in the database.

More detail:

-> Using null=True on String-based Fields:
When you use null=True on a string-based field like CharField or TextField,
you're allowing that field to store NULL values in the database, in addition to empty strings.
This means the field can have two possible values to represent "no data" (i.e. NULL and an empty string '').

Django's convention is to use the empty string ('') to represent "no data" for string-based fields.

Here's an example:

class Product(models.Model):
    name = models.CharField(max_length=100, null=True)

In this example, if you set null=True on the name field, it will allow the field to store both NULL and empty strings.

summary:
It's often better to leave null=False (the default) for string-based fields, so an empty string can be used to represent "no data".
For other types of fields like numbers or dates, using null=True can be appropriate when you want to differentiate between "no data" and an actual numeric or date value.

-> exception for above scenerio:

If you do not give null=True and have a field with unique=True and blank=True,
then having multiple NULL values will indeed violate the uniqueness constraint.

class Product(models.Model):
    code = models.CharField(max_length=10, unique=True, blank=True)

# Creating two products with NULL code values
product1 = Product.objects.create(code=None)
product2 = Product.objects.create(code=None)

In this example, if you attempt to create both product1 and product2 with NULL values for the code field, you will encounter a uniqueness constraint violation.
This is because, by default, without null=True, NULL values are treated as equal and will violate the uniqueness constraint set by unique=True.

To avoid this issue and allow multiple NULL values for the field while maintaining uniqueness for non-NULL values, you would need to set null=True.

class Product(models.Model):
    code = models.CharField(max_length=10, unique=True, blank=True, null=True)

# Creating two products with NULL code values
product1 = Product.objects.create(code=None)
product2 = Product.objects.create(code=None)

In this case, with null=True, the uniqueness constraint will not be violated because each NULL value is considered distinct, and you can have multiple rows with NULL code values.

In summary, using null=True along with unique=True and blank=True can help handle scenarios where you want to allow multiple blank or NULL values while still enforcing uniqueness on the non-empty values.

***************
blank:

The blank option is used at the validation and form level.
It specifies whether a field is required when creating a form to input data.

If blank=True is set on a field, it means that the field is not required when creating a form.
If blank=False (the default) is set, the field is required.

Example:

class MyModel(models.Model):
    some_field = models.CharField(max_length=50, blank=True)

In this example, some_field is not required when creating a form.

***************

In summary:

'null' is related to the database and determines whether a field can hold NULL values.
'blank' is related to form validation and determines whether a field is required when creating a form.

It's also worth noting that some field types have default behaviors for null and blank.

For example,

CharField and TextField have blank set to False by default (field is required), while
DateField and DateTimeField have null set to True by default.

1) If you have a CharField with blank=True (null=False by default) and you create a record without giving a value for that field, Django will store an empty string ('') in the database for that field.

2) If you have a CharField with both blank=True and null=True, and you create a record without giving a value for that field, Django will store a NULL value in the database for that field.

**************************************************************************
https://docs.djangoproject.com/en/4.2/topics/db/models/#verbose-field-names

Verbose field names

Each field type, except for ForeignKey, ManyToManyField and OneToOneField, takes an optional first positional argument – a verbose name.
If the verbose name isn’t given, Django will automatically create it using the field’s attribute name, converting underscores to spaces.

In this example, the verbose name is "person's first name":
first_name = models.CharField("person's first name", max_length=30)

In this example, the verbose name is "first name":
first_name = models.CharField(max_length=30)


ForeignKey, ManyToManyField and OneToOneField require the first argument to be a model class, so use the verbose_name keyword argument:
poll = models.ForeignKey(
    Poll,
    on_delete=models.CASCADE,
    verbose_name="the related poll",
)
sites = models.ManyToManyField(Site, verbose_name="list of sites")
place = models.OneToOneField(
    Place,
    on_delete=models.CASCADE,
    verbose_name="related place",
)

The convention is not to capitalize the first letter of the verbose_name.
Django will automatically capitalize the first letter where it needs to.

****************

In Django, the verbose_name and verbose_name_plural attributes are used to provide human-readable names for model fields and their related models.
These attributes are not strictly necessary for the functionality of your application, but they greatly improve the readability and user-friendliness of your code and the admin interface.

class Book(models.Model):
    title = models.CharField(max_length=200, verbose_name="book Title")
    author = models.CharField(max_length=100, verbose_name="author's Name")
    publication_year = models.PositiveIntegerField(verbose_name="publication Year")
    is_available = models.BooleanField(default=True, verbose_name="is Available")

    class Meta:
        verbose_name = "Book"
        verbose_name_plural = "Books"

Readability and Clarity: We use verbose_name to provide more descriptive names for our fields. Instead of using generic names like title, author, etc., we provide meaningful labels like "Book Title," "Author's Name," etc.

Admin Interface: In the Django admin interface, the labels provided by verbose_name will be displayed for each field. Users of the admin interface will see these labels, which make it clear what each field represents.

Documentation and Collaboration: Other developers working on the project will immediately understand the purpose of each field when reading the code. For instance, verbose_name="Publication Year" communicates that the field represents the publication year of the book.

Internationalization and Localization: Imagine you want to make your application multilingual. With verbose_name, you can provide translations for different languages. For instance, you can have translations for "Book Title" in different languages, allowing your application to display the appropriate label based on the user's language preferences.


**************************************************************************
https://docs.djangoproject.com/en/4.2/topics/db/models/#field-name-restrictions

Field name restrictions

Django places some restrictions on model field names:

1) A field name cannot be a Python reserved word, because that would result in a Python syntax error. For example:

class Example(models.Model):
    pass = models.IntegerField() # 'pass' is a reserved word!

2) A field name cannot contain more than one underscore in a row, due to the way Django’s query lookup syntax works. For example:

class Example(models.Model):
    foo__bar = models.IntegerField()  # 'foo__bar' has two underscores!

3) A field name cannot end with an underscore, for similar reasons.

These limitations can be worked around, though, because your field name doesn’t necessarily have to match your database column name. See the db_column option.

SQL reserved words, such as join, where or select, are allowed as model field names, because Django escapes all database table names and column names in every underlying SQL query. It uses the quoting syntax of your particular database engine.

**************************************************************************



**************************************************************************
