===================================================================================================
Resources:
===================================================================================================

https://docs.djangoproject.com/en/4.2/ref/
https://docs.djangoproject.com/en/4.2/contents/
https://docs.djangoproject.com/en/4.2/topics/
https://docs.djangoproject.com/en/3.2/contents/

https://www.geeksforgeeks.org/tag/python-django/

https://www.tutorialspoint.com/django/index.htm

**********************

Hi, thanks for joining the coding community!
Every month, i will send you a summary of all my latest content, which includes my newest videos, blog posts and programming tips.
In the mean time,you can check out my youtube channel where i teach programming:
https://www.youtube.com/c/CodeWithTomi


Free Resources:

Django Roadmap: https://www.dropbox.com/s/opzvs43bwqpvr8c/Django%20Roadmap%20-%20Google%20Docs.pdf?dl=0

Django Projects Cheat Sheet: https://www.dropbox.com/s/s54nyhbslh8fqxg/Django%20Projects%20cheat%20sheet%20-%20Google%20Docs.pdf?dl=0

Python Data Structures: https://www.dropbox.com/s/bpof9qic77kjlfj/PYTHON%20DATA%20STRUCTURES%20%281%29.pdf?dl=0

Git Cheat Sheet: https://www.dropbox.com/s/ubyvjp84cq42m5r/Git%20Cheat%20Sheet%20-%20Google%20Docs.pdf?dl=0


===================================================================================================
frequently used commands
===================================================================================================

1) reload shell:
exit()
python manage.py shell
from my_models.models import *
from many_to_many_relationship.models import *
from many_to_one_relationship.models import *

2) migrate:
python manage.py makemigrations
python manage.py migrate

3)
upgrade django version

pip install --upgrade django



===================================================================================================
initial Setup (using pipenv)
===================================================================================================

pipenv:

https://medium.com/@piyushmaurya23/setting-up-django-using-pipenv-cf8ff9b2caa6

1. Make a directory for the django project
2. Install 'pip install pipenv' in the system environment if not already
3. Create a virtual environment by running 'pipenv shell'
    (the location of the venv defaults to '~/user/.virtualenv/', to make it live inside the current directory, make an empty folder named '.venv',
    pipenv automatically detects that folder and creates the virtual environment inside that folder)
    ( default location in my ubuntu: /home/dev/.local/share/virtualenvs/Projects-IqmR9ahX )
4. Now install django by running 'pipenv install django' (installs the latest version)
5. Start the project by running 'django-admin startproject $NAME_OF_THE_PROJECT'
6. To start the live server cd into the project and run 'python manage.py runserver port(optional)'
7. To make a new app inside that project run 'python manage.py startapp $NAME_OF_THE_APP'


show all packages installed globally
> pip freeze


create env with requirement.txt file:
> pipenv install -r ./requirements.txt

check any security issue in installed packages:
> pipenv check
update in pipfile and run "pipenv install"


List packages with dependency graph:
> pipenv graph

List packages in plain format:
> pip list


update lock file with the installed version in case you install latest version of some package and it shows "*" in pipfile and then insatll using lock file when you deploy:
> pipenv lock

pipenv install --ignore-pipfile

run command in virtual environment without activating it:
pipenv run python


**********************
summary:

Go into dir where you want your virtual environment:

First install pipenv using "pip install pipenv"

1) create ".venv" director,
2) pipenv install             --  will create Pipfile and lock file and create virtual environment
3) pipenv install django      -- install package
4) pipenv shell		      -- activate virtual environment

5) Create a new Django project called P1_DjangoModels with the following command.

django-admin startproject P1_DjangoModels .              -- create project in the same dir

django-admin startproject P1_DjangoModels		   -- create project in its sub directory

**********************

Add interpreter path for project in VScode

1) Run this commad to get path to virtual environment 
pipenv --venv 

2) Add the path to virtual environment by appending "/bin/python"

===================================================================================================
create virtual environment using virtualenv: (old way)
===================================================================================================

$ python --version
Python 3.8.10

$ python -m venv venv

$ source venv/bin/activate

$ pip install -r requirements.txt 

$ pip install --upgrade pip

$ pip list

===================================================================================================
Initial Setup (old)
===================================================================================================

https://www.youtube.com/watch?v=UmljXZIypDc&list=PL-osiE80TeTtoQCKZ03TU5fNfx2UY6U4p&index=1&t=405s
corey schafer
https://github.com/CoreyMSchafer/code_snippets/tree/master/Django_Blog
*********************************************

pip install django

python -m django --version
or
python -c "import django; print(django.get_version())"

django-admin     --------  list all sub-commands

*********************************************

create project:

django-admin startproject project_name

wsgi  how our web_application and browser_server will commmunicate

*********************************************


python manage.py runserver

http://localhost:8000/
http://127.0.0.1:8000/


ctrl+c to stop server

*********************************************


Django documentation

https://docs.djangoproject.com/en/3.2/

*********************************************

a single project can contain multiple apps

python manage.py startapp name_of_app

python manage.py startapp blog

python manage.py startapp users


*********************************************
Create app inside project:

1) python manage.py startapp name_of_app

python manage.py startapp my_models

2) Register app in installed_app in settings.py file:

INSTALLED_APPS = [
    # ...
    'my_models.apps.MyModelsConfig',
    # ...
]

3) Add urls of the app in main urls.py:

a) create urls.py file in app.
b) register this url file in main urls.py:
    from django.contrib import admin
    from django.urls import path, include

    urlpatterns = [
        path('admin/', admin.site.urls),
        path('', include('blog.urls')),
    ]

4) add model in current app's admin.py file:

from django.contrib import admin
from .models import Person

admin.site.register(Person)


**********************************

naming convention for apps:

Here are a few examples of app names following the convention:

blog (for a blogging app)
ecommerce (for an e-commerce app)
user_profile (for a user profile app)
inventory_management (for an inventory management app)
event_calendar (for an event calendar app)


===================================================================================================
Logging and debugging
===================================================================================================

debugging:

import pdb; pdb.set_trace()

*************************

diff ways of getting sql in shell:

1) paster in shell:

import logging
log = logging.getLogger('django.db.backends')
log.setLevel(logging.DEBUG)
log.addHandler(logging.StreamHandler())

2) for simple logs add this code to settings.py file:

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'DEBUG',  # Set this to the desired logging level
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'level': 'DEBUG',  # Set this to the desired logging level
            'propagate': False,
        },
    },
}

3) add this code to settings.py for formatted sql:

import sqlparse
import logging

class SqlFormatter(logging.Formatter):
    def format(self, record):
        statement = record.getMessage()
        formatted_statement = sqlparse.format(statement, reindent=True)
        return formatted_statement


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'sql',  # Use the 'sql' formatter for SQL queries
        },
    },
    'formatters': {
        'sql': {
            '()': SqlFormatter,  # Use the full path to your custom formatter class
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'DEBUG',  # Set this to the desired logging level
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'l
===================================================================================================
pipenv initial
===================================================================================================

https://medium.com/@piyushmaurya23/setting-up-django-using-pipenv-cf8ff9b2caa6

1. Make a directory for the django project
2. Install 'pip install pipenv' in the system environment if not already
3. Create a virtual environment by running 'pipenv shell' (the location of the venv defaults to '~/user/.virtualenv/',
	 to make it live inside the current directory, make an empty folder named '.venv', pipenv automatically detects that folder and creates the virtual environment inside that folder)
4. Now install django by running 'pipenv install django' (installs the latest version)
5. Start the project by running 'django-admin startproject $NAME_OF_THE_PROJECT'
6. To start the live server cd into the project and run 'python manage.py runserver port(optional)'
7. To make a new app inside that project run 'python manage.py startapp $NAME_OF_THE_APP'


show all packages installed globally
> pip freeze


create env with requirement.txt file:
> pipenv install -r ./requirements.txt

check any security issue in installed packages:
> pipenv check
update in pipfile and run "pipenv install"


show dependencies
pipenv graph


update lock file with the installed version in case you install latest version of some package and it shows "*" in pipfile and then insatll using lock file when you deploy:
pipenv lock

pipenv install --ignore-pipfile


run command in virtual environment without activating it:
pipenv run python

install or remove dependencies:
pipenv install selenium
pipenv uninstall selenium

**********************


Go into dir where you want your virtual environment:

First install pipenv using "pip install pipenv"

1) create ".venv" director,
2) pipenv install             -- will create Pipfile and lock file and create virtual environment
3) pipenv install django      -- install package
4) pipenv shell		          -- activate virtual environment

5) Create a new Django project called P1_DjangoModels with the following command.

django-admin startproject P1_DjangoModels .              -- create project in the same dir

django-admin startproject P1_DjangoModels		   -- create project in its sub directory

evel': 'DEBUG',  # Set this to the desired logging level
            'propagate': False,
        },
    },
}

4) If you're in the shell, or anywhere for that matter, you can use the queryset method

query.as_sql()
to print the SQL command.

ie:

MyModel.objects.all().query.as_sql()

===================================================================================================
Django Basics
===================================================================================================

Create Project heirarchy

1) Create virtual environment:

python -m venv myenv        -- create virtual environment
myenv\Scripts\activate      -- activate it

pip install django
pip install django-crispy-forms

2) django-admin startproject djangoPractice

3) To create your app, make sure you’re in the same directory as manage.py and type this command:
   python manage.py startapp myapp

4) Its useful to register app in settings.py file immediately
	'myapp.apps.MyappConfig'


myenv\Scripts\activate
cd mysite


python manage.py runserver


********************************************

Create views

1) create urls.py in the app

2) include this url file in main url file

from django.contrib import admin
from django.urls import path, include

urlpatterns = [                                  # note write / after route else it cause error
    path('admin/', admin.site.urls),
    path('myapp/', include('myapp.urls'))
]


3) craeate urls + views

from django.urls import path
from . import views

urlpatterns=[
    path( '', views.index , name="index" )

]

from django.http import HttpResponse
def index(requuest):
     return HttpResponse("hello world")



**********************************************

render html :

1) first register app in settings.py file
'myapp.apps.MyappConfig'

2) create templates in myapp  ( by default django look in templates folder as base directory )

myapp -> templates  -> myapp -> index.html

3) create view

from django.shortcuts import render

def index2(request):
    return render(request, "myapp/index.html")

*******

Your project’s TEMPLATES setting describes how Django will load and render templates.
The default settings file configures a DjangoTemplates backend whose APP_DIRS option is set to True. By convention DjangoTemplates looks for a “templates” subdirectory in each of the INSTALLED_APPS.

*********

Here’s a setup that tells the Django template engine to load templates from the templates subdirectory inside each installed application:

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "APP_DIRS": True,
    },
]


****************************************************

creating models:

1)

create model in model class ----

from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    date_posted = models.DateTimeField(default=timezone.now)
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    # on_delete : if the user is deleted , then we want to delete their posts as well

    def __str__(self):  # dunder(double underscore) str method
        return self.title


# DateTimeField(auto_now = True)   -> for last modified field
# DateTimeField(auto_now-add = True)   -> save current date when object is created but we cannot modify that date
# use on_delete=models.SET_NULL to just add null on delete related table

2)

create models and register in admin.py file in app

from .models import Post
admin.site.register(Question)


3)

To run migrations we first need to create super user

	python manage.py createsuperuser

3)

Re run the Migrations commands in order to get changes to our database.

a) python manage.py makemigrations

b) python manage.py sqlmigrate blog 0001   #  it prints out the code that is going to run

c) python manage.py migrate


***************************************************

Manipulate database

see official docs   ---  https://docs.djangoproject.com/en/4.0/intro/tutorial02/

Create User in cmd  ---  https://www.codegrepper.com/code-examples/python/django+add+user+command+line

1) python manage.py shell

2) >>> from app.Models import Post
3) >>> from django.contrib.auth.models import User

4) User.objects.all()
4) User.objects.first()
4) User.objects.filter(username='nouman')
4) User.objects.filter(username='nouman').first()


5) a) user = User.objects.filter(username='nouman').first()
   b)  user.post_set
   b)  user.post_set.all()


6) exit()  to exit from shell

see database.txt also



===================================================================================================
https://stackoverflow.com/questions/75495403/django-returns-templatedoesnotexist-when-using-crispy-forms

Forms:

1) As of django-crispy-forms 2.0 the template packs are now in separate packages.
Install both packages:

pip install django-crispy-forms
pip install crispy-bootstrap4


2)register this app in settings.py
'crispy_forms',
'crispy_bootstrap4',

3) CRISPY_TEMPLATE_PACK = 'bootstrap4'

4) create forms.py file and creaete form:

from django import forms
class PostForm(forms.Form):
    title = forms.CharField(max_length=100)
    content = forms.CharField(widget=forms.Textarea)



5) create view as :

def new_post(request):
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = PostForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            title = form.cleaned_data['title']
            content = form.cleaned_data['content']
            post = Post(title=title, content=content, author_id=1)
            post.save()
            return redirect('posts')
    else:
        form = PostForm()
    return render(request, 'myapp/myForm.html', {'form': form})


4) create html file myForm.html
inside your_html.html file add {% load crispy_forms_tags %} and you can use cripy_forms as you like

************************************



load static data:


add this in settings.py file  ---  STATIC_URL = '/static/'

by default django look static file in this heirarchy ( so create this structure)
app -> static-> app-> staticfile

to add static file in html page:

{% load static %}

 <link rel="stylesheet" type="text/css" href="{% static 'myapp/bootstrap.min.css' %}">

===================================================================================================
Django Basic Lines:
===================================================================================================


from django.contrib import admin
from django.contrib.auth import views as auth_views
from django.urls import path, include
from users import views as user_views

urlpatterns = [
    path('admin/', admin.site.urls),
    # path('blog/', include('blog.urls')),    # all the blog views will start from  blog/...
    path('', include('blog.urls')),
    path('register/', user_views.register, name='register'),
    path('login/', auth_views.LoginView.as_view(), name='login'),
    path('logout/', auth_views.LogoutView.as_view(), name='logout'),
]

****************************

# names can be used to redirect to this specific route as

return redirect('register')

<a class="ml-2" href="{% url 'register' %}">Sign Up Now</a>

********************************************

path('post/<int:pk>/', PostDetailView.as_view(), name='post-detail')

href="{% url 'post-detail' post.id %}"   in html file ( blog app)

===================================================================================================
Django Ecommerce
===================================================================================================


Check Python
check pip
create project
connect database in setting.py



Part 2
1. Create App = store
2. Register The app in settings.py
3. INclude the app's urls.py file in the main urls file
4. create the templates structure
5. Create the home path and views function and render the index.html template


part 3:
1. create category and product models and register in admin.py file
2. make migrations and migrate
	(env) D:\Python Django Project\Ecommerce Website>       python manage.py makemigration
	(env) D:\Python Django Project\Ecommerce Website>	pythom manage.py migrate


3. create superuser

	python manage.py createsuperuser

	(env) D:\Python Django Project\Ecommerce Website>python manage.py createsuperuser
	Username (leave blank to use 'nouman'):
	Email address: noumanrehman042@gmail.com
	Password: 1234 (invisible)
	Password (again):1234
	This password is too short. It must contain at least 8 characters.
	This password is too common.
	This password is entirely numeric.
	Bypass password validation and create user anyway? [y/N]: y
	Superuser created successfully.


4. pip install django-jazzmin
  and register it in installed apps as 'jazzmin' in settings.py file


8. Django Ecommerce Part 8 | User registration in django | Custom User register form using bootstrap
	User registration in django:

https://www.youtube.com/watch?v=q6oxoOxvUMk&list=PL_99hMDlL4d2zsGU5nOgADmRc6A8msXyh&index=8



===================================================================================================
Django Installations
===================================================================================================

pip install django

pip install django-crispy-forms

pip install Pillow    --   library to work with images with python

===================================================================================================
Django Apps
===================================================================================================

https://docs.djangoproject.com/en/4.2/ref/applications/

Django contains a registry of installed applications that stores configuration and provides introspection.
It also maintains a list of available models.

This registry is called apps and it’s available in django.apps:

>>> from django.apps import apps

>>> apps.get_app_config("admin").verbose_name
'Administration'

>>> apps.ready
Boolean attribute that is set to True after the registry is fully populated and
all AppConfig.ready() methods are called.


>>> apps.get_app_configs()
It Returns an iterable of AppConfig instances.

dict_values([<AdminConfig: admin>, <AuthConfig: auth>, <ContentTypesConfig: contenttypes>,
<SessionsConfig: sessions>, <MessagesConfig: messages>, <StaticFilesConfig: staticfiles>,
<MyViewsConfig: my_views>, <AppConfig: crispy_forms>, <PollsConfig: polls>,
<MyClassBasedViewsConfig: my_class_based_views>, <EmployeeAppConfig: employee_app>,
 <BookshelfConfig: bookshelf>, <TaskManagerConfig: task_manager>])

>>> apps.get_app_config(app_label)

apps.get_app_config('polls')
<PollsConfig: polls>

Returns an AppConfig for the application with the given app_label.
Raises LookupError if no such application exists.


*************

>>> apps.get_model("polls", "Question")
>>> apps.get_model("polls.Question")
>>> apps.get_model("polls.question")

syntax:
apps.get_model(app_label, model_name, require_ready=True)¶

Returns the Model with the given app_label and model_name.
As a shortcut, this method also accepts a single argument in the form app_label.model_name.
model_name is case-insensitive.


****************************
All methods of apps registry:

>>> from django.apps import apps

methods we can use with this 'apps':

apps.all_models                    apps.clear_cache(                  apps.get_model(                    apps.lazy_model_operation(         apps.ready_event                   apps.unset_available_apps(
apps.app_configs                   apps.do_pending_operations(        apps.get_models(                   apps.loading                       apps.register_model(               apps.unset_installed_apps(
apps.apps_ready                    apps.get_app_config(               apps.get_registered_model(         apps.models_ready                  apps.set_available_apps(
apps.check_apps_ready(             apps.get_app_configs(              apps.get_swappable_settings_name(  apps.populate(                     apps.set_installed_apps(
apps.check_models_ready(           apps.get_containing_app_config(    apps.is_installed(                 apps.ready                         apps.stored_app_configs


****************************
Application configuration
****************************

class AppConfig:

Application configuration objects store metadata for an application.
Each application's AppConfig class provides metadata and configuration for the application, such as its name, label, models, middleware, and other settings.
Some attributes can be configured in AppConfig subclasses. Others are set by Django and read-only.

>>> from django.apps import apps

>>> app_config = apps.get_app_config('polls')
<PollsConfig: polls>

>>> app_config.verbose_name
'Polls'

>>> app_config.name
'polls'

>>> app_config.label
'polls'

>>> app_config.path
'/home/dev/django_training/Projects/P2_DjangoBasics/polls'


>>> app_config.module
<module 'polls' from '/home/dev/django_training/Projects/P2_DjangoBasics/polls/__init__.py'>

All methods on app_config:

app_config.apps                app_config.get_model(          app_config.label               app_config.module              app_config.ready(
app_config.create(             app_config.get_models(         app_config.models              app_config.name                app_config.verbose_name
app_config.default_auto_field  app_config.import_models(      app_config.models_module       app_config.path

********************************

Initialization process:

https://docs.djangoproject.com/en/4.2/ref/applications/#initialization-process

In Django, when the framework starts up, the django.setup() function is responsible for populating the application registry and performing various initialization tasks.
The setup() function is typically called automatically when Django's management commands like runserver, migrate, or shell.

The django.setup() function performs several important tasks:

1) Populating the Application Registry: As you mentioned, one of the main tasks of setup() is to populate the application registry.
It does this by scanning the installed apps and their corresponding AppConfig classes.
Each application's AppConfig class provides metadata and configuration for the application, such as its name, label, models, middleware, and other settings.

2) Setting Up Settings: The setup() function also ensures that the settings for the project are properly configured and ready to be used. This includes loading settings from the project's settings.py file and applying any necessary modifications.

3) Loading Middleware: Middleware components are classes that process requests and responses globally in Django. The setup() function loads and configures the middleware defined in the project's settings.

4) Initializing Database Connections: If the project uses a database, setup() sets up and configures the database connections based on the database settings defined in the project's settings.

5) Initializing Template Engine: If you're using Django's template system, setup() initializes the template engine and configures template-related settings.

6) Other Initialization Tasks: Apart from the tasks mentioned above, setup() handles other initialization tasks like setting up logging, loading translation catalogs, and more.

In most cases, as a developer, you don't need to explicitly call django.setup() yourself. It's automatically called by Django when you run management commands like runserver, migrate, or shell.
However, if you're writing custom scripts or tools outside of Django's management commands, you might need to call setup() before interacting with Django's components.

Keep in mind that the details of Django's internal workings might change with different versions of the framework, so it's a good practice to refer to the official documentation for the most accurate and up-to-date information.


===================================================================================================
Url configuration/mapping/routing
===================================================================================================
https://docs.djangoproject.com/en/4.2/topics/http/urls/#

Path converters
The following path converters are available by default:

str - Matches any non-empty string, excluding the path separator, '/'. This is the default if a converter isn’t included in the expression.
int - Matches zero or any positive integer. Returns an int.
slug - Matches any slug string consisting of ASCII letters or numbers, plus the hyphen and underscore characters. For example, building-your-1st-django-site.
uuid - Matches a formatted UUID. To prevent multiple URLs from mapping to the same page, dashes must be included and letters must be lowercase. For example, 075194d3-6885-417e-a8a8-6c931e272f00. Returns a UUID instance.
path - Matches any non-empty string, including the path separator, '/'. This allows you to match against a complete URL path rather than a segment of a URL path as with str.

**********************

Getting parameters:

path( 'index3/<int:id>', views.index3 , name="index3" ),
path( 'index4/<str:name>', views.index4 , name="index4" )

path('user/<int:id>', views.getUserById, name="getUser")

************

from django.http import  HttpResponse

def index3(request, id):
    return HttpResponse(f"hello world {id}")

def index4(request, name):
    return HttpResponse(f"hello world {name}")


def getUserById(request, id):
    user = User.objects.get(id=id)
    profile = {
        "name": user.username,
        "email":user.email
    }
    return JsonResponse(profile)


*****************************************
Passing extra options to view functions:

URLconfs have a hook that lets you pass extra arguments to your view functions, as a Python dictionary.
The path() function can take an optional third argument which should be a dictionary of extra keyword arguments to pass to the view function.

For example:

from django.urls import path
from . import views

urlpatterns = [
    path("blog/<int:year>/", views.year_archive, {"foo": "bar"}),
]

In this example, for a request to /blog/2005/, Django will call views.year_archive(request, year=2005, foo='bar').

This technique is used in the syndication framework to pass metadata and options to views.

Dealing with conflicts
It’s possible to have a URL pattern which captures named keyword arguments, and also passes arguments with the same names in its dictionary of extra arguments. When this happens, the arguments in the dictionary will be used instead of the arguments captured in the URL.

*****************************

Passing extra options to include():

Similarly, you can pass extra options to include() and each line in the included URLconf will be passed the extra options.

For example, these two URLconf sets are functionally identical:

Set one: ************

# main.py
from django.urls import include, path

urlpatterns = [
    path("blog/", include("inner"), {"blog_id": 3}),
]

# inner.py
from django.urls import path
from mysite import views

urlpatterns = [
    path("archive/", views.archive),
    path("about/", views.about),
]


Set two: ************

# main.py
from django.urls import include, path
from mysite import views

urlpatterns = [
    path("blog/", include("inner")),
]

# inner.py
from django.urls import path

urlpatterns = [
    path("archive/", views.archive, {"blog_id": 3}),
    path("about/", views.about, {"blog_id": 3}),
]


Note that extra options will always be passed to every line in the included URLconf, regardless of whether the line’s view actually accepts those options as valid. For this reason, this technique is only useful if you’re certain that every view in the included URLconf accepts the extra options you’re passing.

*******************************
other related topics:

1) reverse vs reverse_lazy
2) Namespacing URL names

see in polls app


===================================================================================================
Django Forms
===================================================================================================
https://docs.djangoproject.com/en/4.2/topics/forms/
https://docs.djangoproject.com/en/4.2/ref/forms/api/#ref-forms-api-configuring-label

The Form class:

forms.py
from django import forms

class NameForm(forms.Form):
    your_name = forms.CharField(label="Your name", max_length=100)


The whole form, when rendered for the first time, will look like:

<label for="your_name">Your name: </label>
<input id="your_name" type="text" name="your_name" maxlength="100" required>

Note that it does not include the <form> tags, or a submit button.
We’ll have to provide those ourselves in the template.

**************************
Bound and unbound form instances
The distinction between Bound and unbound forms is important:

An unbound form has no data associated with it. When rendered to the user, it will be empty or will contain default values.

A bound form has submitted data, and hence can be used to tell if that data is valid. If an invalid bound form is rendered, it can include inline error messages telling the user what data to correct.
The form’s is_bound attribute will tell you whether a form has data bound to it or not.

***************************
Widgets:

Each form field has a corresponding Widget class, which in turn corresponds to an HTML form widget such as <input type="text">.

In most cases, the field will have a sensible default widget.
For example:
By default, a CharField will have a TextInput widget, that produces an <input type="text"> in the HTML.
If you needed <textarea> instead, you’d specify the appropriate widget when defining your form field,
as we have done for the message field.

****************************
Form rendering options

There are other output options though for the <label>/<input> pairs:

{{ form.as_div }} will render them wrapped in <div> tags.
{{ form.as_table }} will render them as table cells wrapped in <tr> tags.
{{ form.as_p }} will render them wrapped in <p> tags.
{{ form.as_ul }} will render them wrapped in <li> tags.

Note that you’ll have to provide the surrounding <table> or <ul> elements yourself.

Here’s the output of {{ form.as_p }} for our ContactForm instance:

<p><label for="id_subject">Subject:</label>
    <input id="id_subject" type="text" name="subject" maxlength="100" required></p>
<p><label for="id_message">Message:</label>
    <textarea name="message" id="id_message" required></textarea></p>
<p><label for="id_sender">Sender:</label>
    <input type="email" name="sender" id="id_sender" required></p>
<p><label for="id_cc_myself">Cc myself:</label>
    <input type="checkbox" name="cc_myself" id="id_cc_myself"></p>
Note that each form field has an ID attribute set to id_<field-name>, which is referenced by the accompanying label tag. This is important in ensuring that forms are accessible to assistive technology such as screen reader software. You can also customize the way in which labels and ids are generated.

****************************

Looping over the form’s fields

If you’re using the same HTML for each of your form fields, you can reduce duplicate code by looping through each field in turn using a {% for %} loop:

{% for field in form %}
    <div class="fieldWrapper">
        {{ field.errors }}
        {{ field.label_tag }} {{ field }}
        {% if field.help_text %}
          <p class="help" id="{{ field.auto_id }}_helptext">
            {{ field.help_text|safe }}
          </p>
        {% endif %}
    </div>
{% endfor %}

Useful attributes on {{ field }} include:

{{ field.errors }}
Outputs a <ul class="errorlist"> containing any validation errors corresponding to this field. You can customize the presentation of the errors with a {% for error in field.errors %} loop. In this case, each object in the loop is a string containing the error message.

{{ field.field }}
The Field instance from the form class that this BoundField wraps. You can use it to access Field attributes, e.g. {{ char_field.field.max_length }}.

{{ field.help_text }}
Any help text that has been associated with the field.

{{ field.html_name }}
The name of the field that will be used in the input element’s name field. This takes the form prefix into account, if it has been set.

{{ field.id_for_label }}
The ID that will be used for this field (id_email in the example above). If you are constructing the label manually, you may want to use this in lieu of label_tag. It’s also useful, for example, if you have some inline JavaScript and want to avoid hardcoding the field’s ID.

{{ field.is_hidden }}
This attribute is True if the form field is a hidden field and False otherwise. It’s not particularly useful as a template variable, but could be useful in conditional tests such as:
{% if field.is_hidden %}
   {# Do something special #}
{% endif %}

{{ field.label }}
The label of the field, e.g. Email address.

{{ field.label_tag }}
The field’s label wrapped in the appropriate HTML <label> tag. This includes the form’s label_suffix.
 For example, the default label_suffix is a colon:
<label for="id_email">Email address:</label>

{{ field.legend_tag }}
Similar to field.label_tag but uses a <legend> tag in place of <label>, for widgets with multiple inputs wrapped in a <fieldset>.

{{ field.value }}
The value of the field. e.g someone@example.com.

******************************************************************************************

Form initialization and validation process:

1) Form Initialization: When you create an instance of a form, such as form = MyForm(request.POST), the form's constructor initializes its fields and sets the initial data. However, the cleaned_data dictionary is not populated at this stage.

2) Form Validation: After initializing the form, you usually call the is_valid() method to trigger the validation process.
This process involves several steps:

    a) Field Cleaning: The clean() method of each field is called. This method handles field-specific cleaning logic, such as converting input values, validating formats, etc.
    The cleaned data for each field is temporarily stored in the field's cleaned() method until the entire form validation is complete.

    b) Custom Clean Methods: If you've defined custom clean methods in your form class (e.g., clean_<field_name>()), these methods are also called during the validation process.
    These methods can perform cross-field validation or more complex checks.

    c) Form Clean Method: If you've defined a clean() method in your form class (not to be confused with field-specific clean methods), it's called at the end of the validation process.
    This method can perform additional validation or checks that involve multiple fields.

3) Populating cleaned_data: Once the entire validation process is successfully completed (no validation errors were raised), the cleaned data for each field is collected and stored in the cleaned_data dictionary.
The keys in the dictionary are the field names, and the values are the cleaned and validated values of the respective fields.

After the validation process is finished and you've called is_valid() on the form, you can access the cleaned_data attribute to retrieve the cleaned values.
If any validation errors occurred during the process, they will be stored in the errors attribute of the form, and cleaned_data won't be populated for that field.
 
If we access the `cleaned_data` attribute, directly after initializing the form, it will throw an exception.
AttributeError: 'YourForm' object has no attribute 'cleaned_data'

******************************************************************************************
The Forms API

https://docs.djangoproject.com/en/4.2/ref/forms/api/#module-django.forms

from my_forms.forms import ContactForm

>>> data = {
    "subject": "hello",
    "message": "Hi there",
    "sender": "foo@example.com",
    "cc_myself": True,
}

>>> f = ContactForm(data)

>>> f = ContactForm()
>>> f.is_bound
False

>>> f = ContactForm({"subject": "hello"})
>>> f.is_bound
True

Note that passing an empty dictionary creates a bound form with empty data:

>>> f = ContactForm({})
>>> f.is_bound
True

If you have a bound Form instance and want to change the data somehow,
or if you want to bind an unbound Form instance to some data,
create another Form instance. There is no way to change data in a Form instance.
Once a Form instance has been created, you should consider its data immutable, whether it has data or not.
************************

Using forms to validate data

>>> f.is_valid()

Let’s try with some invalid data:

>>> data = {
    "subject": "",
    "message": "Hi there",
    "sender": "invalid email address",
    "cc_myself": True,
}
>>> f = ContactForm(data)
>>> f.is_valid()
False
************************

Form.errors:
Access the errors attribute to get a dictionary of error messages:

>>> f.errors
{'sender': ['Enter a valid email address.'], 'subject': ['This field is required.']}
In this dictionary, the keys are the field names, and the values are lists of strings representing the error messages. The error messages are stored in lists because a field can have multiple error messages.

You can access errors without having to call is_valid() first.
The form’s data will be validated the first time either you call is_valid() or access errors.

************************

Form.errors.as_data()
Returns a dict that maps fields to their original ValidationError instances.

f.errors.as_data()
{'subject': [ValidationError(['This field is required.'])], 'sender': [ValidationError(['Enter a valid email address.'])]}

************************

Form.errors.as_json(escape_html=False):
Returns the errors serialized as JSON.

>>> f.errors.as_json()
'{"subject": [{"message": "This field is required.", "code": "required"}], "sender": [{"message": "Enter a valid email address.", "code": "invalid"}]}'

1) escape_html=False:
By default, when you use as_json(), it does not escape its output.
Escaping means converting characters that have special meaning in HTML, like <, >, and &, into their HTML entity equivalents (e.g., &lt;, &gt;, &amp;).
If you're using the JSON output in contexts like AJAX requests, where the client interprets the response and inserts errors into the page,
 you need to ensure that you properly escape the JSON on the client-side to prevent cross-site scripting (XSS) attacks.

For example, when adding the JSON error messages to the page using JavaScript, you should set the error text as text content (element.textContent = errorText) rather than HTML content (element.innerHTML = errorText),
which can help prevent unintentional script execution.

2) escape_html=True:
If you want to use the error messages directly in HTML without manual escaping on the client-side, you can set escape_html=True.
 This will cause the error messages to be escaped within the JSON, making them safe for direct insertion into HTML content.

Note:
If you plan to use this JSON in a web page context, it's important to handle escaping properly to prevent security vulnerabilities.

***********************
Form.errors.get_json_data(escape_html=False):

Returns the errors as a dictionary suitable for serializing to JSON.
Form.errors.as_json() returns serialized JSON, while this returns the error data before it’s serialized.

The escape_html parameter behaves as described in Form.errors.as_json().

>>> f.errors.get_json_data()
{'subject': [{'message': 'This field is required.', 'code': 'required'}], 'sender': [{'message': 'Enter a valid email address.', 'code': 'invalid'}]}

The main use case for get_json_data() is when you need more control over how the error data is processed and serialized before being converted to JSON.
This can be helpful if you want to apply additional logic or transformation to the error data before rendering it as JSON.

For example:
def my_view(request):
    if request.method == 'POST':
        form = MyForm(request.POST)
        if not form.is_valid():
            # Retrieve error data as a dictionary
            error_data = form.errors.get_json_data()
            # Perform additional processing or manipulation if needed
            processed_error_data = my_custom_process_function(error_data)
            # Convert processed error data to JSON
            json_error_data = json.dumps(processed_error_data)
            return HttpResponse(json_error_data, content_type='application/json')
    else:
        form = MyForm()
    return render(request, 'my_template.html', {'form': form})

**************************

Form.add_error(field, error):

This method allows adding errors to specific fields from within the Form.clean() method, or from outside the form altogether; for instance from a view.

The field argument is the name of the field to which the errors should be added. If its value is None the error will be treated as a non-field error as returned by Form.non_field_errors().

The error argument can be a string, or preferably an instance of ValidationError. See Raising ValidationError for best practices when defining form errors.

Note that Form.add_error() automatically removes the relevant field from cleaned_data.

Example:
1)

>>> f.cleaned_data
{'message': 'Hi there', 'cc_myself': True}
>>> f.add_error('message', "Message is too short")
>>> f.cleaned_data
{'cc_myself': True}
>>> f.errors
{'subject': ['This field is required.'], 'sender': ['Enter a valid email address.'], 'message': ['Message is too short']}

2)

from django import forms

class EmailForm(forms.Form):
    email = forms.EmailField()

    def clean_email(self):
        email = self.cleaned_data.get('email')
        if email and 'example.com' not in email:
            self.add_error('email', "Email must be from example.com domain")
        return email

*********************
Form.has_error(field, code=None):

This method returns a boolean designating whether a field has an error with a specific error code.
If code is None, it will return True if the field contains any errors at all.

To check for non-field errors use NON_FIELD_ERRORS as the field parameter.

>>> f.has_error('subject')
True

*********************

Form.non_field_errors():

This method returns the list of errors from Form.errors that aren’t associated with a particular field.
This includes ValidationErrors that are raised in Form.clean() and errors added using Form.add_error(None, "...").

>>> f.non_field_errors()

*********************
Behavior of unbound forms:

It’s meaningless to validate a form with no data, but, for the record, here’s what happens with unbound forms:

>>> f = ContactForm()
>>> f.is_valid()
False
>>> f.errors
{}

************************************************************************************
Initial form values:

Form.initial:
Use initial to declare the initial value of form fields at runtime.
For example, you might want to fill in a username field with the username of the current session.

To accomplish this, use the initial argument to a Form. This argument, if given, should be a dictionary mapping field names to initial values.
Only include the fields for which you’re specifying an initial value; it’s not necessary to include every field in your form.

For example:

>>> f = ContactForm(initial={"subject": "Hi there!"})
]>>> f.is_bound
False

These values are only displayed for unbound forms, and they’re not used as fallback values if a particular value isn’t provided.

If a Field defines initial and you include initial when instantiating the Form, then the latter initial will have precedence.
In this example, initial is provided both at the field level and at the form instance level, and the latter gets precedence:

>>> from django import forms
>>> class CommentForm(forms.Form):
...     name = forms.CharField(initial="class")
...     url = forms.URLField()
...     comment = forms.CharField()
...
>>> f = CommentForm(initial={"name": "instance"}, auto_id=False)
>>> print(f)
<tr><th>Name:</th><td><input type="text" name="name" value="instance" required></td></tr>
<tr><th>Url:</th><td><input type="url" name="url" required></td></tr>
<tr><th>Comment:</th><td><input type="text" name="comment" required></td></tr>

*********************

Form.get_initial_for_field(field, field_name):

Returns the initial data for a form field.
It retrieves the data from Form.initial if present, otherwise trying Field.initial.
Callable values are evaluated.

>>> f.get_initial_for_field(f.fields["subject"], "subject")
'Hi there!'


************************************************************************************
Checking which form data has changed:

Form.has_changed()¶
Use the has_changed() method on your Form when you need to check if the form data has been changed from the initial data.

>>> data = {'subject': 'hello',
    'message': 'Hi there',
    'sender': 'foo@example.com',
    'cc_myself': True
}
>>> f = ContactForm(data, initial=data)
>>> f.is_bound
True
>>> f.has_changed()
False

When the form is submitted, we reconstruct it and provide the original data so that the comparison can be done:
>>> f = ContactForm(request.POST, initial=data)
>>> f.has_changed()

has_changed() will be True if the data from request.POST differs from what was provided in initial or False otherwise.
The result is computed by calling Field.has_changed() for each field in the form.

*************************

Form.changed_data:
The changed_data attribute returns a list of the names of the fields whose values in the form’s bound data (usually request.POST) differ from what was provided in initial. It returns an empty list if no data differs.

>>> f = ContactForm(request.POST, initial=data)
>>> if f.has_changed():
...     print("The following fields changed: %s" % ", ".join(f.changed_data))
>>> f.changed_data
['subject', 'message']

******************************************************************************************
Accessing the fields from the form

Form.fields:

>>> for row in f.fields.values():
...     print(row)
...
<django.forms.fields.CharField object at 0x7ffaac632510>
<django.forms.fields.URLField object at 0x7ffaac632f90>
<django.forms.fields.CharField object at 0x7ffaac3aa050>

>>> f.fields["name"]
<django.forms.fields.CharField object at 0x7ffaac6324d0>

You can alter the field and BoundField of Form instance to change the way it is presented in the form:

>>> f.as_div().split("</div>")[0]
'<div><label for="id_subject">Subject:</label><input type="text" name="subject" maxlength="100" required id="id_subject">'

>>> f["subject"].label = "Topic"

>>> f.as_div().split("</div>")[0]
'<div><label for="id_subject">Topic:</label><input type="text" name="subject" maxlength="100" required id="id_subject">'

***********************
f.base_fields vs  f.fields

Both f.base_fields and f.fields provide information about the fields in a form,
the key difference is that f.base_fields contains the original field instances defined in the form class,
while f.fields represents the fields that will be displayed on the current form instance, considering any dynamic modifications you've made.

******************************************************************************************
Accessing “clean” data:

Form.cleaned_data:
Each field in a Form class is responsible not only for validating data, but also for “cleaning” it – normalizing it to a consistent format.
This is a nice feature, because it allows data for a particular field to be input in a variety of ways, always resulting in consistent output.

For example, DateField normalizes input into a Python datetime.date object. Regardless of whether you pass it a string in the format '1994-07-15', a datetime.date object, or a number of other formats, DateField will always normalize it to a datetime.date object as long as it’s valid.

Once you’ve created a Form instance with a set of data and validated it, you can access the clean data via its cleaned_data attribute:

>>> data = {
    "subject": "hello",
    "message": "Hi there",
    "sender": "foo@example.com",
    "cc_myself": True,
}
>>> f = ContactForm(data)
>>> f.is_valid()
True
>>> f.cleaned_data
{'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'}

Note that any text-based field – such as CharField or EmailField – always cleans the input into a string.

If your data does not validate, the cleaned_data dictionary contains only the valid fields:

************************
cleaned_data will always only contain a key for fields defined in the Form,
even if you pass extra data when you define the Form.
In this example, we pass a bunch of extra fields to the ContactForm constructor, but cleaned_data contains only the form’s fields:

>>> data = {
...     "subject": "hello",
...     "message": "Hi there",
...     "sender": "foo@example.com",
...     "cc_myself": True,
...     "extra_field_1": "foo",
...     "extra_field_2": "bar",
...     "extra_field_3": "baz",
... }
>>> f = ContactForm(data)
>>> f.is_valid()
True
>>> f.cleaned_data  # Doesn't contain extra_field_1, etc.
{'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'}

************************
When the Form is valid, cleaned_data will include a key and value for all its fields,
even if the data didn’t include a value for some optional fields.

In this example, the data dictionary doesn’t include a value for the nick_name field,
but cleaned_data includes it, with an empty value:

>>> from django import forms
>>> class OptionalPersonForm(forms.Form):
...     first_name = forms.CharField()
...     last_name = forms.CharField()
...     nick_name = forms.CharField(required=False)
...
>>> data = {"first_name": "John", "last_name": "Lennon"}
>>> f = OptionalPersonForm(data)
>>> f.is_valid()
True
>>> f.cleaned_data
{'nick_name': '', 'first_name': 'John', 'last_name': 'Lennon'}

In this above example, the cleaned_data value for nick_name is set to an empty string, because nick_name is CharField, and CharFields treat empty values as an empty string.
Each field type knows what its “blank” value is – e.g., for DateField, it’s None instead of the empty string.
For full details on each field’s behavior in this case, see the “Empty value” note for each field in the “Built-in Field classes” section below.

You can write code to perform validation for particular form fields (based on their name) or for the form as a whole (considering combinations of various fields). More information about this is in Form and field validation.

******************************************************************************************
Configuring form elements’ HTML id attributes and <label> tags¶

Form.auto_id:

By default, the form rendering methods include:

1) HTML id attributes on the form elements. The id attribute values are generated by prepending id_ to the form field names
2) The corresponding <label> tags around the labels. An HTML <label> tag designates which label text is associated with which form element. 
This small enhancement makes forms more usable and more accessible to assistive devices. It’s always a good idea to use <label> tags.

>>> f = ContactForm(auto_id=False)
>>> print(f.as_div())

<div>Subject:<input type="text" name="subject" maxlength="100" required></div>
<div>Message:<textarea name="message" cols="40" rows="10" required></textarea></div>
<div>Sender:<input type="email" name="sender" required></div>
<div>Cc myself:<input type="checkbox" name="cc_myself"></div>

****************

If auto_id is set to True, then the form output will include <label> tags and 
will use the field name as its id for each form field ( instead of id_<field_name> ):

>>> f = ContactForm(auto_id=True)
>>> print(f.as_div())
<div><label for="subject">Subject:</label><input type="text" name="subject" maxlength="100" required id="subject"></div>
<div><label for="message">Message:</label><textarea name="message" cols="40" rows="10" required id="message"></textarea></div>
<div><label for="sender">Sender:</label><input type="email" name="sender" required id="sender"></div>
<div><label for="cc_myself">Cc myself:</label><input type="checkbox" name="cc_myself" id="cc_myself"></div>

****************
If auto_id is set to a string containing the format character '%s', then the form output will include <label> tags,
and will generate id attributes based on the format string.

For example, for a format string 'field_%s', a field named subject will get the id value 'field_subject'. Continuing our example:

>>> f = ContactForm(auto_id="id_for_%s")
>>> print(f.as_div())
<div><label for="id_for_subject">Subject:</label><input type="text" name="subject" maxlength="100" required id="id_for_subject"></div>
<div><label for="id_for_message">Message:</label><textarea name="message" cols="40" rows="10" required id="id_for_message"></textarea></div>
<div><label for="id_for_sender">Sender:</label><input type="email" name="sender" required id="id_for_sender"></div>
<div><label for="id_for_cc_myself">Cc myself:</label><input type="checkbox" name="cc_myself" id="id_for_cc_myself"></div>

By default, auto_id is set to the string 'id_%s'.

*****************************************
Form.label_suffix:

A translatable string (defaults to a colon (:) in English) that will be appended after any label name when a form is rendered.

It’s possible to customize that character, or omit it entirely, using the label_suffix parameter:

>>> f = ContactForm(auto_id="id_for_%s", label_suffix="")
>>> print(f.as_div())
<div><label for="id_for_subject">Subject</label><input type="text" name="subject" maxlength="100" required id="id_for_subject"></div>
<div><label for="id_for_message">Message</label><textarea name="message" cols="40" rows="10" required id="id_for_message"></textarea></div>
<div><label for="id_for_sender">Sender</label><input type="email" name="sender" required id="id_for_sender"></div>
<div><label for="id_for_cc_myself">Cc myself</label><input type="checkbox" name="cc_myself" id="id_for_cc_myself"></div>

>>> f = ContactForm(auto_id="id_for_%s", label_suffix=" ->")
>>> print(f.as_div())
<div><label for="id_for_subject">Subject -&gt;</label><input type="text" name="subject" maxlength="100" required id="id_for_subject"></div>
<div><label for="id_for_message">Message -&gt;</label><textarea name="message" cols="40" rows="10" required id="id_for_message"></textarea></div>
<div><label for="id_for_sender">Sender -&gt;</label><input type="email" name="sender" required id="id_for_sender"></div>
<div><label for="id_for_cc_myself">Cc myself -&gt;</label><input type="checkbox" name="cc_myself" id="id_for_cc_myself"></div>

Note that the label suffix is added only if the last character of the label isn’t a punctuation character (in English, those are ., !, ? or :).

Fields can also define their own label_suffix. This will take precedence over Form.label_suffix.
The suffix can also be overridden at runtime using the label_suffix parameter to label_tag()/ legend_tag().

***************************************************

Form.use_required_attribute:

It controls whether the HTML attribute required is added to form fields marked as required in the form.
When set to True(the default), the required attribute is added to the HTML input elements, which prompts browsers to enforce client-side validation on those fields.

This will remove required attribute from the fields (i.e.remove frontend validations)
>>> f = ContactForm(use_required_attribute=False)
>>> print(f)
******************************************************************************************
Outputting forms as HTML¶

There are other output options though for the <label>/<input> pairs:

{{ form.as_div }} will render them wrapped in <div> tags.
{{ form.as_table }} will render them as table cells wrapped in <tr> tags.
{{ form.as_p }} will render them wrapped in <p> tags.
{{ form.as_ul }} will render them wrapped in <li> tags.

******************************************************************************************

More granular output¶

class BoundField¶
Used to display HTML or access attributes for a single field of a Form instance.
The __str__() method of this object displays the HTML for this field.

To retrieve a single BoundField, use dictionary lookup syntax on your form using the field’s name as the key:

>>> form = ContactForm()
>>> print(form["subject"])
<input id="id_subject" type="text" name="subject" maxlength="100" required>

To retrieve all BoundField objects, iterate the form:
>>> form = ContactForm()
>>> for boundfield in form:
    print(boundfield)
**************************

Attributes of BoundField:

>>> form = ContactForm(initial={"subject":"initial subject"})
>>> form["subject"].initial
>>> form["subject"].data
>>> form["subject"].errors
>>> form["subject"].field
>>> form["subject"].help_text
>>> form["subject"].html_name
>>> form["subject"].id_for_label
>>> form["subject"].label
>>> form["subject"].name
>>> form["subject"].css_classes()
>>> form["subject"].value()

Usage example:

from django import forms

class FeedbackForm(forms.Form):
    subject = forms.CharField(max_length=100, label="Subject:")
    message = forms.CharField(widget=forms.Textarea, label="Message:")
    sender = forms.EmailField(label="Your Email:")
    cc_myself = forms.BooleanField(required=False, label="Send me a copy")

# Assume that this is a view function that handles form submissions

def submit_feedback(request):
    if request.method == 'POST':
        form = FeedbackForm(request.POST)
        if form.is_valid():
            # Process the form data
            subject = form.cleaned_data['subject']
            message = form.cleaned_data['message']
            sender = form.cleaned_data['sender']
            cc_myself = form.cleaned_data['cc_myself']

            # Perform further actions like sending emails, saving to database, etc.
            # ...
    else:
        form = FeedbackForm(initial={"subject": "Initial subject"})

    return render(request, 'feedback.html', {'form': form})


# feedback.html:
<form method="post">
    {% csrf_token %}

    <!-- Custom rendering using attributes and methods -->
    <label for="{{ form.subject.id_for_label }}">{{ form.subject.label }}</label>
    <input type="text" name="{{ form.subject.name }}" id="{{ form.subject.id_for_label }}"
           class="{{ form.subject.css_classes }}" value="{{ form.subject.value }}">
    <span class="help-text">{{ form.subject.help_text }}</span>
    <ul class="error-list">
        {% for error in form.subject.errors %}
            <li>{{ error }}</li>
        {% endfor %}
    </ul>

    <!-- ... Repeat the above pattern for other fields ... -->

    <button type="submit">Submit</button>
</form>

*************************************

form.fields['field_name'].initial   vs   form.field_name.initial

In Django templates, you can access form fields using the syntax form.field_name,
and this is possible because the template system provides a context that includes the form object and its fields.

However, when you're working in Python code, such as in the Python shell or a Django view function,
you don't have direct access to form fields using the form.field_name syntax.
Instead, you interact with form fields using their names as keys to access their data, initial values, and more.
This is because the context in Python code is different from the context provided by the Django template system.


******************************************************************************************

All methods on form instance:

f.add_error(              f.as_ul(                  f.data                    f.field_order             f.has_changed(            f.is_valid(               f.render(                 f.template_name_table
f.add_initial_prefix(     f.auto_id                 f.declared_fields         f.fields                  f.has_error(              f.label_suffix            f.renderer                f.template_name_ul
f.add_prefix(             f.base_fields             f.default_renderer        f.files                   f.hidden_fields(          f.media                   f.template_name           f.use_required_attribute
f.as_div(                 f.changed_data            f.empty_permitted         f.full_clean(             f.initial                 f.non_field_errors(       f.template_name_div       f.visible_fields(
f.as_p(                   f.clean(                  f.error_class(            f.get_context(            f.is_bound                f.order_fields(           f.template_name_label
f.as_table(               f.cleaned_data            f.errors                  f.get_initial_for_field(  f.is_multipart(           f.prefix                  f.template_name_p
>>> f.



===================================================================================================
Authentication and Authorization
===================================================================================================
Authentication and authorization are two fundamental concepts in computer security and access control.
Authentication and authorization work together to create a layered security approach.
Authentication ensures that only legitimate users gain access to a system,
while authorization ensures that authenticated users have appropriate access rights.
Implementing strong authentication and authorization practices is essential for protecting sensitive data, preventing unauthorized access, and maintaining the overall security of a system or application.


Authentication:
Authentication is the process of verifying the identity of a user, system, or entity. It ensures that the entity claiming a particular identity is indeed who it claims to be.
Authentication mechanisms are used to prevent unauthorized access and ensure that only legitimate users can access resources or perform actions within a system.

There are several methods of authentication, including:

1) Username and Password: This is the most common method where users provide a unique username and a secret password.
2) Multi-Factor Authentication (MFA): In addition to a password, another piece of evidence is required, such as a one-time code sent to a mobile device.
3) Biometric Authentication: This includes fingerprint scans, facial recognition, and other physiological characteristics to verify identity.
4) Token-based Authentication: Users are provided with a token or key that is used as proof of identity.
5) Certificate-based Authentication: Digital certificates are used to authenticate users or systems.

*************************

Authorization:

Authorization, on the other hand, comes after authentication and involves determining what actions or resources a user is allowed to access after their identity has been verified. Authorization ensures that authenticated users have appropriate permissions to perform specific actions or access certain resources within a system. It defines the scope of a user's privileges and controls what they can and cannot do. Authorization can be implemented through role-based access control (RBAC) or attribute-based access control (ABAC), among other methods.

2) Role-Based Access Control (RBAC): Users are assigned roles, and these roles have specific permissions associated with them. Users can perform actions based on their assigned roles.
3) Attribute-Based Access Control (ABAC):
Access decisions are made based on attributes associated with users, resources, and the environment.
It provides more fine-grained control over access.

Example for ABAC:

Scenario: File-Sharing System

Imagine a file-sharing system where users can upload and access various files.
 The system uses ABAC to control access to files based on attributes such as user roles, file types, and sensitivity levels.

Attributes:
Role: Users can have roles such as "Employee" and "Manager."
File Type: Files can be categorized as "Documents," "Spreadsheets," or "Presentations."
Sensitivity Level: Files are assigned sensitivity levels: "Low," "Medium," and "High."

Attribute-Based Access Control Rules:
Access to Files:
    Employees can access "Documents" and "Spreadsheets" files.
    Managers can access all types of files.
Sensitive Files:
    Only users with a sensitivity level of "High" can access files marked as "High" sensitivity.

Example Scenarios:

Jane, an employee, wants to access a presentation file. The ABAC system checks her role ("Employee") and the file type ("Presentation"). Since she has the appropriate role for the file type, she's granted access.
Alex, a manager, tries to access a spreadsheet. The ABAC system checks his role ("Manager") and the file type ("Spreadsheet"), so he's allowed to access the file.
Lisa, an employee, attempts to access a "High" sensitivity document. The ABAC system checks her role ("Employee") and the sensitivity level of the file ("High"). Since her sensitivity level doesn't match the requirement, access is denied.
Mark, a manager, needs to access a "High" sensitivity presentation. The ABAC system verifies his role ("Manager") and the sensitivity level of the file ("High"), granting him access.

In this simple example, ABAC is used to control access to files based on attributes like roles, file types, and sensitivity levels. Access control decisions are made dynamically based on the attributes associated with the user and the resources they're trying to access. This example illustrates how ABAC can provide fine-grained control over access, allowing for more flexible and context-aware authorization decisions.

**************************************************
Authentication in web requests
**************************************************

Authentication in web requests is a process by which a client (usually a user or another system) provides credentials to a server to prove its identity. This is essential for ensuring that only authorized users or systems can access specific resources or perform actions on a web application. There are several common methods of implementing authentication in web requests:

Basic Authentication:
Basic authentication is a simple method where the client includes a username and password in the HTTP request headers. The credentials are usually base64-encoded for transmission, although it's important to note that this encoding doesn't provide strong security on its own. Basic authentication is often used with HTTPS to encrypt the credentials during transmission.

Example of headers:
Authorization: Basic base64(username:password)
*****************

Digest Authentication:
Digest authentication is a more secure alternative to basic authentication. It involves the server challenging the client with a nonce value that the client combines with the username, password, and other data to produce a hash. This hash is sent back to the server for verification. Digest authentication helps prevent sending plain-text passwords over the network.
*****************

Token-Based Authentication:
Token-based authentication involves the use of tokens instead of sending credentials with each request. After successful login, the server provides the client with a token that the client includes in the headers of subsequent requests. This token is often digitally signed to prevent tampering. Token-based authentication is commonly used in modern web applications and APIs.

Example of headers:
Authorization: Bearer <token>

*****************

OAuth and OAuth2:
OAuth (Open Authorization) and OAuth2 are authentication and authorization protocols that allow a user to grant limited access to their resources on one site to another site without exposing their credentials. OAuth2, the newer version, is widely used for granting access to third-party applications or services. It involves obtaining an access token after user consent and using that token for making authorized API requests.

*****************
JWT (JSON Web Tokens):
JWT is a compact, URL-safe means of representing claims between two parties. It's often used as a token format for token-based authentication. A JWT contains encoded information (claims) that can include user identity, expiration time, and other metadata. The server signs the JWT, and the client includes it in headers to authenticate and access protected resources.

These authentication methods help secure web requests by verifying the identity of clients and ensuring that only authorized users or systems can interact with a web application's resources. The choice of authentication method depends on factors such as security requirements, ease of implementation, and the specific use case of the web application.


===================================================================================================
Models
Model Field options
===================================================================================================
https://docs.djangoproject.com/en/4.2/ref/models/fields/#field-options

NULL vs BLANK

null:
The null option is used at the database level and determines whether a field can store a NULL value in the database.
It's relevant for database columns.

If you set null=True on a field, it means that the field's database column can hold a NULL value, indicating the absence of data.
If you set null=False (which is the default), it means that the field cannot hold NULL values.

Example:

class MyModel(models.Model):
    some_field = models.CharField(max_length=50, null=True)

In this example, some_field can store NULL values in the database.

More detail:

-> Using null=True on String-based Fields:
When you use null=True on a string-based field like CharField or TextField,
you're allowing that field to store NULL values in the database, in addition to empty strings.
This means the field can have two possible values to represent "no data" (i.e. NULL and an empty string '').

Django's convention is to use the empty string ('') to represent "no data" for string-based fields.

Here's an example:

class Product(models.Model):
    name = models.CharField(max_length=100, null=True)

In this example, if you set null=True on the name field, it will allow the field to store both NULL and empty strings.

summary:
It's often better to leave null=False (the default) for string-based fields, so an empty string can be used to represent "no data".
For other types of fields like numbers or dates, using null=True can be appropriate when you want to differentiate between "no data" and an actual numeric or date value.

-> exception for above scenerio:

If you do not give null=True and have a field with unique=True and blank=True,
then having multiple NULL values will indeed violate the uniqueness constraint.

class Product(models.Model):
    code = models.CharField(max_length=10, unique=True, blank=True)

# Creating two products with NULL code values
product1 = Product.objects.create(code=None)
product2 = Product.objects.create(code=None)

In this example, if you attempt to create both product1 and product2 with NULL values for the code field, you will encounter a uniqueness constraint violation.
This is because, by default, without null=True, NULL values are treated as equal and will violate the uniqueness constraint set by unique=True.

To avoid this issue and allow multiple NULL values for the field while maintaining uniqueness for non-NULL values, you would need to set null=True.

class Product(models.Model):
    code = models.CharField(max_length=10, unique=True, blank=True, null=True)

# Creating two products with NULL code values
product1 = Product.objects.create(code=None)
product2 = Product.objects.create(code=None)

In this case, with null=True, the uniqueness constraint will not be violated because each NULL value is considered distinct, and you can have multiple rows with NULL code values.

In summary, using null=True along with unique=True and blank=True can help handle scenarios where you want to allow multiple blank or NULL values while still enforcing uniqueness on the non-empty values.

************************************************************
blank:
************************************************************

The blank option is used at the validation and form level.
It specifies whether a field is required when creating a form to input data.

If blank=True is set on a field, it means that the field is not required when creating a form.
If blank=False (the default) is set, the field is required.

Example:

class MyModel(models.Model):
    some_field = models.CharField(max_length=50, blank=True)

In this example, some_field is not required when creating a form.

***************

In summary:

'null' is related to the database and determines whether a field can hold NULL values.
'blank' is related to form validation and determines whether a field is required when creating a form.

It's also worth noting that some field types have default behaviors for null and blank.

For example,

CharField and TextField have blank set to False by default (field is required), while
DateField and DateTimeField have null set to True by default.

1) If you have a CharField with blank=True (null=False by default) and you create a record without giving a value for that field, Django will store an empty string ('') in the database for that field.

2) If you have a CharField with both blank=True and null=True, and you create a record without giving a value for that field, Django will store a NULL value in the database for that field.

**************************************************************************
Verbose field names
**************************************************************************
https://docs.djangoproject.com/en/4.2/topics/db/models/#verbose-field-names

In Django, the verbose_name attribute is used to specify a human-readable name for a model field or a model class. 
It provides a more descriptive name for the field or the model that is used in the Django admin interface, forms, and other places where the model's details are displayed.

Each field type, except for ForeignKey, ManyToManyField and OneToOneField, takes an optional first positional argument – a verbose name.
If the verbose name isn’t given, Django will automatically create it using the field’s attribute name, converting underscores to spaces.

For example, consider a User model with a field first_name. 
Instead of displaying the field as "First Name" in the admin interface, you can use verbose_name="First Name" to make it more readable and intuitive.

class User(models.Model):
    first_name = models.CharField(max_length=50, verbose_name="First Name")
    # Other fields...
    

In this example, the verbose name is "person's first name":
first_name = models.CharField("person's first name", max_length=30)

In this example, the verbose name is "first name":
first_name = models.CharField(max_length=30)


ForeignKey, ManyToManyField and OneToOneField require the first argument to be a model class, so use the verbose_name keyword argument:
poll = models.ForeignKey(
    Poll,
    on_delete=models.CASCADE,
    verbose_name="the related poll",
)
sites = models.ManyToManyField(Site, verbose_name="list of sites")
place = models.OneToOneField(
    Place,
    on_delete=models.CASCADE,
    verbose_name="related place",
)

The convention is not to capitalize the first letter of the verbose_name.
Django will automatically capitalize the first letter where it needs to.

****************

In Django, the verbose_name and verbose_name_plural attributes are used to provide human-readable names for model fields and their related models.
These attributes are not strictly necessary for the functionality of your application, but they greatly improve the readability and user-friendliness of your code and the admin interface.

class Book(models.Model):
    title = models.CharField(max_length=200, verbose_name="book Title")
    author = models.CharField(max_length=100, verbose_name="author's Name")
    publication_year = models.PositiveIntegerField(verbose_name="publication Year")
    is_available = models.BooleanField(default=True, verbose_name="is Available")

    class Meta:
        verbose_name = "Book"
        verbose_name_plural = "Books"

Readability and Clarity: We use verbose_name to provide more descriptive names for our fields. Instead of using generic names like title, author, etc., we provide meaningful labels like "Book Title," "Author's Name," etc.

Admin Interface: In the Django admin interface, the labels provided by verbose_name will be displayed for each field. Users of the admin interface will see these labels, which make it clear what each field represents.

Documentation and Collaboration: Other developers working on the project will immediately understand the purpose of each field when reading the code. For instance, verbose_name="Publication Year" communicates that the field represents the publication year of the book.

Internationalization and Localization: Imagine you want to make your application multilingual. With verbose_name, you can provide translations for different languages. For instance, you can have translations for "Book Title" in different languages, allowing your application to display the appropriate label based on the user's language preferences.


**************************************************************************
Field name restrictions
**************************************************************************

https://docs.djangoproject.com/en/4.2/topics/db/models/#field-name-restrictions

Django places some restrictions on model field names:

1) A field name cannot be a Python reserved word, because that would result in a Python syntax error. For example:

class Example(models.Model):
    pass = models.IntegerField() # 'pass' is a reserved word!

2) A field name cannot contain more than one underscore in a row, due to the way Django’s query lookup syntax works. For example:

class Example(models.Model):
    foo__bar = models.IntegerField()  # 'foo__bar' has two underscores!

3) A field name cannot end with an underscore, for similar reasons.

These limitations can be worked around, though, because your field name doesn’t necessarily have to match your database column name. See the db_column option.

SQL reserved words, such as join, where or select, are allowed as model field names, because Django escapes all database table names and column names in every underlying SQL query. It uses the quoting syntax of your particular database engine.


*************************************************************************************************
Listing 7-7. Django model default options for dates and times, as well as auto_now and auto_now_add use
*************************************************************************************************

https://www.webforefront.com/django/modeldatatypesandvalidation.html


from datetime import date
from django.utils import timezone

class Store(models.Model):
    name = models.CharField(max_length=30)    
    address = models.CharField(max_length=30)

    date = models.DateField(default=date.today)
    datetime = models.DateTimeField(default=timezone.now)

    date_lastupdated = models.DateField(auto_now=True)
    date_added = models.DateField(auto_now_add=True)

    timestamp_lastupdated = models.DateTimeField(auto_now=True)
    timestamp_added = models.DateTimeField(auto_now_add=True)

*****************************************

Don't add () PARENTHESIS to methods in default values:
If you look closely at the default values from previous listings, notice they lack () in their syntax, which creates an important behavior. 
By omitting the () syntax, Python assigns a reference to a method and evaluates the expression until runtime, but if you use the () syntax (e.g. default=timezone.now()) Python evaluates the expression at compile time. 
For functions that return fixed values this is a non-issue, but for functions that return dynamically calculated values (e.g. dates) this is critical, otherwise you get a single value calculated at compile time (e.g. the date or datetime field would contain the same value calculated at compile time for all records).

*****************************************

auto_now=True and auto_now_add=True options:

Both of these options work like the default option -- in the sense they add a default date or date & time -- but have a slightly different behavior. 

Values for fields that use either the auto_now and auto_now_add options are generated when a record is created. 

Values for fields that use the "auto_now" option are updated every time a record is changed, 
while values for fields that use the "auto_now_add" option remain frozen for the lifetime of the record. 

By default, DateField fields that use either the auto_now or auto_now_add options generate their value from datetime.date.today(), 
where as DateTimeField fields that use either auto_now or auto_now_add options generate their value from django.utils.timezone.now().

*****************************************

date.today():

date.today() is a function from Python's datetime module that returns a date object representing the current local date.

timezone.now():

timezone.now() is a function from Django's django.utils.timezone module that returns a datetime object representing the current date and time.
It takes into account the timezone settings specified in Django's settings.py file.
This function includes both the date and time components, making it suitable for scenarios where you need both.

*************************************************************************************************
Unique values: unique, unique_for_date, unique_for_month and unique_for_year
*************************************************************************************************

unique:

It's possible to enforce a field value be unique across all records. For example, in listing 7-7 if you change 
name=models.CharField(max_length=30) to name=models.CharField(max_length=30, unique=True) it tells Django to ensure all 
Store records have a unique name value.

The unique option is enforced by Django at the database layer (i.e. by adding a DDL UNIQUE SQL constraint), as well as
the Django/Python layer. In addition, the unique option is valid on all field types except ManyToManyField, 
OneToOneField, and FileField.

unique_for_date:

To enforce uniqueness of a field along with a DateField or DateTimeField value, Django offers the unique_for_date, 
unique_for_month and unique_for_year options. For example, in listing 7-7 to enforce the name field value be unique 
with a date of the date_lastupdated field you can use the name = models.CharField(max_length=30, unique_for_date="date_lastupdated") 
statement which tells Django to allow only one record with the same name and date_lastupdated 
(e.g. you can't have two records with name="Downtown" and date_lastupdated="2018-01-01", but two 
records with name="Downtown" and different date_lastupdated values are allowed).

unique_for_month and unique_for_year options:

The unique_for_month and unique_for_year options provide wider ranges to enforce validation. For example, the name = 
models.CharField(max_length=30, unique_for_month="date_lastupdated") statement tells Django to only allow one record 
with the same name and date_lastupdated value for the same month and the name = models.CharField(max_length=30, 
unique_for_year="date_lastupdated") statement tells Django to only allow one record with the same name and 
date_lastupdated value for the same year.

Due to the more complex requirements of the unique_for_date, unique_for_month and unique_for_year options, the 
enforcement of these options is done at the Django/Python layer. In addition, due to the nature of the validation 
process these options are only valid for DateField and DateTimeField fields, noting that for DateTimeField cases only 
the date portion of the value is used.

**********************************************************************************
Database Definition Language (DDL) values: 
 db_column, db_index, db_tablespace, primary_key
**********************************************************************************

db_column:
By default, Django generates a database table's column names based on a Django model's field names. 
For example, if a Django model field is named 'menu' Django generates a DB column named 'menu'. 
It's possible to override this behavior using the db_column option 
(e.g. name = models.CharField(max_length=30,db_column="my_custom_name") Django generates the DDL with the my_custom_name column name).

db_index:
Another database related option for Django models is the db_index option that tells Django to generate a database index for the field 
(e.g. size = models.CharField(choices=ITEM_SIZES,max_length=1,db_index=True) generates a database index for the size field). 

Be aware that under the following circumstances Django automatically creates a database index, so db_index=True for the following scenarios is redundant:

If a field uses the unique=True option, Django automatically creates an index for the field. You can disable this behavior setting db_index=False.
If a field is a ForeignKey data type, Django automatically creates an index for the field. You can disable this behavior setting db_index=False.

===================================================================================================
Django ORM
===================================================================================================

One of the most powerful features of Django is its Object-Relational Mapper (ORM).
ORM enables you to interact with your database, like you would with SQL. 
In fact, Django's ORM is just a pythonic way to create SQL to query and manipulate your database and get results in a pythonic fashion.

**********************************************************************************
Prefetch_Related And Select_Related Django
**********************************************************************************

https://docs.djangoproject.com/en/4.2/ref/models/querysets/#select-related
https://docs.djangoproject.com/en/4.2/ref/models/querysets/#prefetch-related


Account.objects.all()

(0.000)
SELECT "my_models_account"."id",
       "my_models_account"."person_id",
       "my_models_account"."account_number",
       "my_models_account"."balance"
FROM "my_models_account"
LIMIT 21;

****************

Account.objects.all()[0]

SELECT "my_models_account"."id",
       "my_models_account"."person_id",
       "my_models_account"."account_number",
       "my_models_account"."balance"
FROM "my_models_account"
LIMIT 1;

****************

This will run 2 queries to get related object data:

Account.objects.all()[0].person

SELECT "my_models_account"."id",
       "my_models_account"."person_id",
       "my_models_account"."account_number",
       "my_models_account"."balance"
FROM "my_models_account"
LIMIT 1;


SELECT "my_models_person"."id",
       "my_models_person"."name",
       "my_models_person"."email",
       "my_models_person"."mobile"
FROM "my_models_person"
WHERE "my_models_person"."id" = 3
LIMIT 21;


<Person: Joan louji>


****************************************************************************************
select_related:
****************************************************************************************

* select_related is used to fetch related objects from the database in a single query by performing a SQL join.
* It works for ForeignKey and OneToOneField relationships models.
* When you use select_related, Django fetches the related objects and caches them in memory. This can be particularly useful when you need to access fields of related objects in your code.
* Use select_related when you have a ForeignKey or OneToOneField relationship and you know you will be accessing related object fields. It's efficient for cases where you're fetching a single object and its related object(s).

select_related will fetch all the foreign key related objects in single query:

Account.objects.select_related('person')

(0.000)
SELECT "my_models_account"."id",
       "my_models_account"."person_id",
       "my_models_account"."account_number",
       "my_models_account"."balance",
       "my_models_person"."id",
       "my_models_person"."name",
       "my_models_person"."email",
       "my_models_person"."mobile"
FROM "my_models_account"
INNER JOIN "my_models_person" ON ("my_models_account"."person_id" = "my_models_person"."id")
LIMIT 21;

*****************
this single query to fetch related models data:

Account.objects.select_related('person')[0].person

SELECT "my_models_account"."id",
       "my_models_account"."person_id",
       "my_models_account"."account_number",
       "my_models_account"."balance",
       "my_models_person"."id",
       "my_models_person"."name",
       "my_models_person"."email",
       "my_models_person"."mobile"
FROM "my_models_account"
INNER JOIN "my_models_person" ON ("my_models_account"."person_id" = "my_models_person"."id")
LIMIT 1;


<Person: Joan louji>

******************************

looping through the loaded objetcs and access their related objects:
specify which foreign key related objects to fetch:

This is run only single query for looping:

accounts = Account.objects.select_related('person')

for account in accounts:
  print(account.person.name)

****************************************************************************************
prefetch_related:
****************************************************************************************

prefetch_related fetches the related objects in a separate query and then associates them with the
original objects in Python memory. This approach can be more efficient when dealing with many related objects 
because it avoids the problem of duplicating rows when using SQL joins, which can happen with many-to-many 
relationships.

Account.objects.prefetch_related('person')

(0.000)
SELECT "my_models_account"."id",
       "my_models_account"."person_id",
       "my_models_account"."account_number",
       "my_models_account"."balance"
FROM "my_models_account"
LIMIT 21;


**********************

Account.objects.prefetch_related()[0].person

**********************

from my_models.models import *

customers = Customer.objects.prefetch_related('product_set')

for customer in customers:
  print(customer.product_set.all())

It runs only two queries:

1) to fetch all customers

  SELECT "my_models_customer"."id",
        "my_models_customer"."cus_name",
        "my_models_customer"."cus_email",
        "my_models_customer"."cus_mobile"
  FROM "my_models_customer";

2) To fetch all the products related to these customers:

  SELECT ("my_models_product_customers"."customer_id") AS "_prefetch_related_val_customer_id",
        "my_models_product"."id",
        "my_models_product"."cus_name",
        "my_models_product"."cus_qty"
  FROM "my_models_product"
  INNER JOIN "my_models_product_customers" ON ("my_models_product"."id" = "my_models_product_customers"."product_id")
  WHERE "my_models_product_customers"."customer_id" IN (1,2,3);

****************************************************************************************
differences between select_related and prefetch_related:
****************************************************************************************

https://docs.djangoproject.com/en/4.2/ref/models/querysets/#prefetch-related

-> select_related works by creating an SQL join and including the fields of the related object in the SELECT statement.
For this reason, select_related gets the related objects in the same database query ( does ‘joining’ in sql)
However, to avoid the much larger result set that would result from joining across a ‘many’ relationship, select_related is limited to single-valued relationships - foreign key and one-to-one.
-> select_related only works with foreign key and one-to-one
-> select_related will not work with many-to-many relationship:
  Customer.objects.select_related('product_set')  -- give error


-> prefetch_related, on the other hand, does a separate lookup for each relationship, and does the ‘joining’ in Python.
This allows it to prefetch many-to-many and many-to-one objects ( which cannot be done using select_related ), and it also works for foreign key and one-to-one relationships that are supported by select_related.
It also supports prefetching of GenericRelation and GenericForeignKey, however, it must be restricted to a homogeneous set of results.

For example, prefetching objects referenced by a GenericForeignKey is only supported if the query is restricted to one ContentType.

****************************************************************************************
Complex lookups with Q objects
****************************************************************************************

In Django, the Q object is a powerful tool that allows you to create complex queries using logical operators like AND(&), OR(|), and NOT(~).
It's often used in conjunction with the filter() method to create more advanced database queries.

“A Q object (django.db.models.Q) is an object used to encapsulate a collection of keyword arguments.
These keyword arguments are specified as in ‘Field lookups’”.


from my_models.models import Person
from django.db.models import Q

With Field lookups
>>> Person.objects.filter(name__startswith='a') | Person.objects.filter(name__startswith='s')

With Q object:
>>> Person.objects.filter(Q(name__startswith='a') | Q(name__startswith='s'))

boht will generate same sql:
  SELECT "my_models_person"."id",
        "my_models_person"."name",
        "my_models_person"."email",
        "my_models_person"."mobile"
  FROM "my_models_person"
  WHERE ("my_models_person"."name" LIKE 'a%' ESCAPE '\' OR "my_models_person"."name" LIKE 's%' ESCAPE '\') LIMIT 21; args=('a%', 's%');


******************

Q objects can be combined using the &, |, and ^ operators.
When an operator is used on two Q objects, it yields a new Q object.

For example, this statement yields a single Q object that represents the “OR” of two "question__startswith" queries:

>>> Q(question__startswith="Who") | Q(question__startswith="What")

This is equivalent to the following SQL WHERE clause:
  WHERE question LIKE 'Who%' OR question LIKE 'What%'

*************************

You can compose statements of arbitrary complexity by combining Q objects with the &, |, and ^ operators and use parenthetical grouping.
Also, Q objects can be negated using the ~ operator, allowing for combined lookups that combine both a normal query and a negated (NOT) query:

Q(question__startswith="Who") | ~Q(pub_date__year=2005)

*****************************
Multiple Q objects:

Each lookup function that takes keyword-arguments (e.g. filter(), exclude(), get()) can also be passed one or more Q objects as positional (not-named) arguments.
If you provide multiple Q object arguments to a lookup function, the arguments will be “AND”ed together.

For example:

Poll.objects.get(
    Q(question__startswith="Who"),
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
)

Roughly translates into the SQL:

  SELECT * from polls WHERE question LIKE 'Who%'
      AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')

*****

Person.objects.get(
  Q(name__startswith="joan"),
  Q(email='sjlouji10@gmail.com') | Q(mobile=123412),
)

SELECT "my_models_person"."id",
       "my_models_person"."name",
       "my_models_person"."email",
       "my_models_person"."mobile"
FROM "my_models_person"
WHERE ("my_models_person"."name" LIKE 'joan%' ESCAPE '\' AND ("my_models_person"."email" = 'sjlouji10@gmail.com' OR "my_models_person"."mobile" = '123412')) LIMIT 21; args=('joan%', 'sjlouji10@gmail.com', '123412');


<Person: Joan louji>

*****************************

Lookup functions can mix the use of Q objects and keyword arguments.
All arguments provided to a lookup function (be they keyword arguments or Q objects) are “AND”ed together.
However, if a Q object is provided, it must precede the definition of any keyword arguments. For example:

Poll.objects.get(
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
    question__startswith="Who",
)

would be a valid query, equivalent to the previous example.

****

# INVALID QUERY
Poll.objects.get(
    question__startswith="Who",
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
)


Person.objects.get(
  name__startswith="joan",
  Q(email='sjlouji10@gmail.com') | Q(mobile=123412),
)

SyntaxError: positional argument follows keyword argument
*****************************

The Q object is particularly useful when you need to build queries dynamically based on user input or other runtime conditions.
You can combine multiple Q objects using the logical operators to create even more complex queries:


from django.db.models import Q
from myapp.models import MyModel

q1 = Q(field1__icontains='term1')
q2 = Q(field2__icontains='term2')
q3 = Q(field3__icontains='term3')

# Retrieve objects where either q1 AND q2 OR q3 is true
results = MyModel.objects.filter((q1 & q2) | q3)


===================================================================================================
Querying Data
===================================================================================================
https://docs.djangoproject.com/en/4.2/topics/db/queries/#making-queries

Note: First see all the queries in the relationships section.

Queries allow us to perform CRUD (create, read, update and delete) operations on our Django Models.

Query expressions describe a value or a computation that can be used as part of an update,
create, filter, order by, annotation, or aggregate. When an expression outputs a boolean value, it
may be used directly in filters. There are a number of built-in expressions that can be used to
help you write queries. Expressions can be combined, or in some cases nested, to form more
complex computations.



>>> from querying_data.models import Blog

>>> b = Blog(name="Beatles Blog", tagline="All the latest Beatles news.")
>>> b.save()

**********************

Retrieving a single object with get():

one_entry = Entry.objects.get(pk=1)

>>> from querying_data.models import Blog, Entry
>>> entry = Entry.objects.get(pk=1)
>>> cheese_blog = Blog.objects.get(name="Cheddar Talk")
>>> entry.blog = cheese_blog
>>> entry.save()

*********************************************
Limiting QuerySets (array-slicing):
*********************************************

Use a subset of Python’s array-slicing syntax to limit your QuerySet to a certain number of results. 
This is the equivalent of SQL’s LIMIT and OFFSET clauses.

For example, this returns the first 5 objects (LIMIT 5):
>>> Entry.objects.all()[:5]

This returns the sixth through tenth objects (OFFSET 5 LIMIT 5):
>>> Entry.objects.all()[5:10]

-> Negative indexing (i.e. Entry.objects.all()[-1]) is not supported.

Generally, slicing a QuerySet returns a new QuerySet – it doesn’t evaluate the query. 

-> An exception is if you use the “step” parameter of Python slice syntax. 
For example, this would actually execute the query in order to return a list of every second object of the first 10:
>>> Entry.objects.all()[:10:2]

Further filtering or ordering of a sliced queryset is prohibited due to the ambiguous nature of how that might work.

-> To retrieve a single object rather than a list (e.g. SELECT foo FROM bar LIMIT 1), use an index instead of a slice. 
For example, this returns the first Entry in the database, after ordering entries alphabetically by headline:

>>> Entry.objects.order_by("headline")[0]

This is roughly equivalent to:

>>> Entry.objects.order_by("headline")[0:1].get()

Note, however, that the first of these will raise IndexError while the second will raise DoesNotExist if no objects match the given criteria.

*********************************************
Field lookups
*********************************************
https://docs.djangoproject.com/en/4.2/topics/db/queries/#field-lookups

Lookup functions in Django are methods provided by the Django ORM (Object-Relational Mapping)
that allow you to perform various types of queries on your database.
These functions help you filter, order, and manipulate data in your database tables.
They are often used in combination with the filter() or exclude() methods of querysets to narrow down the set of objects returned.

They enable you to write expressive and precise queries while abstracting away the underlying SQL.

You can use these functions to tailor your queries to your specific requirements and retrieve the data you need from the database.


Here are some commonly used lookup functions in Django:

**********************
exact:
Performs an exact match lookup. It's used to retrieve objects with a field value exactly equal to the provided value.

User.objects.filter(name__exact='john')

SELECT * FROM "my_models_user"
WHERE "my_models_user"."name" = 'john'


**********************
iexact:
Performs a case-insensitive exact match lookup.

User(name="John", email='john@gmail.com').save()
User(name="john", email='john@gmail.com').save()
User(name="JOHN", email='john@gmail.com').save()

User.objects.filter(name__iexact='JOHN')

SELECT * FROM "my_models_user"
WHERE "my_models_user"."name" LIKE 'JOHN' ESCAPE '\'  args=('JOHN',);

-> this will get all the above create objects


**********************

contains:
Checks if the field value contains the specified substring.

from many_to_many_relationship.models import Article

Article.objects.filter(headline__contains='Django')

SELECT * FROM "many_to_many_relationship_article"
WHERE "many_to_many_relationship_article"."headline" LIKE '%Django%' ESCAPE '\' ORDER BY "many_to_many_relationship_article"."headline" ASC  args=('%Django%',);


**********************

icontains:
Case-insensitive version of contains.

**********************

gt and lt: Greater than and less than comparisons.

Product.objects.filter(price__gt=50)

**********************

gte and lte: Greater than or equal to and less than or equal to comparisons.

**********************

in:
Checks if the field value is in a given list.

User.objects.filter(id__in=[1, 2, 3])

SELECT * FROM "my_models_user"
WHERE "my_models_user"."id" IN (1, 2, 3)

**********************

startswith and endswith:

Checks if the field value starts or ends with a specified substring.

Album.objects.filter(title__startswith='The')

SELECT * FROM "my_models_album"
WHERE "my_models_album"."title" LIKE 'The%' ESCAPE '\'  args=('The%',);

**********************

range: 

Finds values within a specified range.

Order.objects.filter(quantity__range=(10, 50))

Track.objects.filter(length__range=(10, 50))

SELECT  * FROM "my_models_track"
WHERE "my_models_track"."length" BETWEEN 10 AND 50

**********************

isnull:
Checks for null values.

Post.objects.filter(comments__isnull=True)

Person.objects.filter(mobile__isnull=True)

SELECT * FROM "my_models_person"
WHERE "my_models_person"."mobile" IS NULL


**********************

date:
Extracts date parts from a DateTimeField.

Event.objects.filter(date__date=datetime.date(2023, 8, 11))


**********************

exact and iexact with foreign keys:

You can use these lookups to filter objects based on their related foreign key fields.


# Example: Retrieve articles written by an author with exact id 1
Article.objects.filter(author__exact=1)

# Example: Retrieve articles written by an author with case-insensitive name 'John'
Article.objects.filter(author__name__iexact='John')
icontains with related fields: You can apply case-insensitive substring matching on related fields.


**********************

# Example: Retrieve users whose email contains 'example.com'
User.objects.filter(profile__email__icontains='example.com')


**********************

year, month, and day: Extract year, month, or day components from a DateField or DateTimeField.


# Example: Retrieve events that occurred in the year 2023
Event.objects.filter(date__year=2023)

# Example: Retrieve articles published in the month of August
Article.objects.filter(pub_date__month=8)

**********************

week_day: Filters objects based on the day of the week (1 for Monday, 7 for Sunday).

# Example: Retrieve tasks scheduled for Fridays
Task.objects.filter(due_date__week_day=5)


**********************

regex: Performs a regular expression match.


# Example: Retrieve products with SKUs that match a specific pattern
Product.objects.filter(sku__regex=r'^[A-Z]{3}-\d{3}$')

**********************

iregex: Case-insensitive version of regex.


# Example: Retrieve products with SKUs that match a specific pattern (case-insensitive)
Product.objects.filter(sku__iregex=r'^[a-z]{3}-\d{3}$')

**********************

exists: Checks if there are any related records.


# Example: Retrieve users who have posted at least one comment
User.objects.filter(comments__exists=True)

**********************

annotate: Adds aggregated values to each object.


from django.db.models import Count

# Example: Retrieve authors with the count of articles they've written
Author.objects.annotate(article_count=Count('articles'))

**********************

F object:

Allows you to reference other fields in the query.

from django.db.models import F

# Example: Retrieve products with price higher than cost price
Product.objects.filter(price__gt=F('cost_price'))

***********************************

Remaining 

===================================================================================================
Sending Emails 
===================================================================================================

use project `Learning-Django/gs62 Registrationn Form extended/enroll`

https://docs.djangoproject.com/en/5.0/topics/email/


Follow these steps to send your emails:

1) Add in setting.py

EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
EMAIL_HOST = "smtp.gmail.com"
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = "nouman.rehman@devsinc.com"
EMAIL_HOST_PASSWORD = "pass" // copy that from notes 


2) In utils.py file:

from django.core.mail import send_mail
from gs62 import settings


def send_email():
    subject = "Hello from Django"
    message = "This is a test email sent from Django."
    from_email = settings.EMAIL_HOST_USER
    recipient_list = [
        "noumanshah436@gmail.com",
    ]

    send_mail(subject, message, from_email, recipient_list)


3) Call this method anaywhere to send email.

from .utils import send_email

send_email()

***********************************
Send Email with attachments:
***********************************

1) create function in utils.py file:

def send_email_with_attachment():
    subject = "Hello from Django"
    message = "This is a test email sent from Django."
    recipient_list = [
        "noumanshah436@gmail.com",
    ]
    file_path = os.path.join(settings.BASE_DIR, "sample.png")

    mail = EmailMessage(
        subject=subject,
        body=message,
        from_email=settings.EMAIL_HOST_USER,
        to=recipient_list,
    )

    mail.attach_file(file_path)

    # To use `attach` method, we can attach like below:
    # with open(file_path, 'rb') as f:
    #     email.attach('sample.png', f.read(), 'image/png')

    mail.send()



2) Call this method anaywhere to send email.

from .utils import send_email_with_attachment

send_email_with_attachment()



***********************************
send_mass_mail
***********************************

The send_mass_mail function in Django is used to send multiple emails to multiple recipients. It is particularly useful when 
you need to send different emails to different recipients in a single function call. This function reduces the overhead of 
multiple SMTP connections by sending all emails in a single connection.


from django.core.mail import send_mass_mail
from django.conf import settings
from django.http import HttpResponse

def send_mass_email_view(request):
    message1 = (
        'Subject 1',
        'Message body 1',
        settings.EMAIL_HOST_USER,
        ['recipient1@example.com']
    )
    
    message2 = (
        'Subject 2',
        'Message body 2',
        settings.EMAIL_HOST_USER,
        ['recipient2@example.com']
    )
    
    messages = [message1, message2]
    
    send_mass_mail(messages, fail_silently=False)
    
    return HttpResponse('Mass email sent successfully!')


***********************************
send_mass_mail() vs. send_mail()
***********************************

The main difference between send_mass_mail() and send_mail() is that send_mail() opens a connection to the mail server each 
time it’s executed, while send_mass_mail() uses a single connection for all of its messages. This makes send_mass_mail() 
slightly more efficient.


***************************************
mail_admins vs mail_managers:
***************************************

In Django, `mail_admins` and `mail_managers` are utility functions used to send error notifications to site administrators and managers, respectively. These functions are particularly useful for sending error messages or important notifications to the people responsible for maintaining the Django application.

### `mail_admins`

`mail_admins` is used to send an email to all the email addresses listed in the `ADMINS` setting. This is typically used to notify site administrators of critical errors.

#### Usage

To use `mail_admins`, first define the `ADMINS` setting in your `settings.py` file:

```python
# settings.py

ADMINS = [
    ('Admin One', 'admin1@example.com'),
    ('Admin Two', 'admin2@example.com'),
]
```

Then, you can use the `mail_admins` function to send an email:

```python
# views.py (or any other appropriate file)

from django.core.mail import mail_admins

def notify_admins_view(request):
    subject = 'Critical Error'
    message = 'A critical error occurred on the site.'
    mail_admins(subject, message)
    return HttpResponse('Admins notified successfully.')
```

#### Configuration

Ensure your email settings are configured correctly in `settings.py`:


### `mail_managers`

`mail_managers` is used to send an email to all the email addresses listed in the `MANAGERS` setting. This is similar to `mail_admins` but is intended for site managers.

#### Usage

To use `mail_managers`, first define the `MANAGERS` setting in your `settings.py` file:

```python
# settings.py

MANAGERS = [
    ('Manager One', 'manager1@example.com'),
    ('Manager Two', 'manager2@example.com'),
]
```

Then, you can use the `mail_managers` function to send an email:

```python
# views.py (or any other appropriate file)

from django.core.mail import mail_managers

def notify_managers_view(request):
    subject = 'Important Notification'
    message = 'An important event has occurred on the site.'
    mail_managers(subject, message)
    return HttpResponse('Managers notified successfully.')
```

#### Configuration

Ensure your email settings are configured correctly in `settings.py`:


### Summary

- **`mail_admins`**: Sends an email to all addresses listed in the `ADMINS` setting. Used for critical error notifications.
- **`mail_managers`**: Sends an email to all addresses listed in the `MANAGERS` setting. Used for important notifications.

Both functions require that the `ADMINS` or `MANAGERS` settings, respectively, are defined, and the email backend is properly configured in `settings.py`.

***********************************************************
send templated email
Sending alternative content types 
***********************************************************

https://docs.djangoproject.com/en/5.0/topics/email/#sending-alternative-content-types

It can be useful to include multiple versions of the content in an email; the classic example is to send both text and HTML 
versions of a message. With Django’s email library, you can do this using the EmailMultiAlternatives class. This subclass of
EmailMessage has an attach_alternative() method for including extra versions of the message body in the email. 
All the other methods (including the class initialization) are inherited directly from EmailMessage.


# utils.py
from django.core.mail import EmailMultiAlternatives


def send_templated_email():
    subject = "Test Email with Template"
    from_email = settings.EMAIL_HOST_USER
    to_email = "noumanshah436@gmail.com"

    # Define the context for the template
    context = {
        "subject": subject,
        "body": "This is a test email with a template.",
    }

    # Load and render the templates
    text_content = render_to_string("enroll/email_template.txt", context)
    html_content = render_to_string("enroll/email_template.html", context)

    # Create the email message
    email = EmailMultiAlternatives(subject, text_content, from_email, [to_email])
    email.attach_alternative(html_content, "text/html")

    # Attach the file
    file_path = os.path.join(settings.BASE_DIR, "sample.png")
    email.attach_file(file_path)

    # Send the email
    email.send()

********************************
# email_template.txt

{{ subject }}

{{ body }}

Visit our site: https://www.example.com

© 2024 Your Company. All rights reserved.

********************************

# email_template.html

<!DOCTYPE html>
<html>
<head>
    <title>{{ subject }}</title>
</head>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; background-color: #f4f4f4; padding: 20px;">
    <div style="max-width: 600px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 5px;">
        <h1 style="color: #333; border-bottom: 1px solid #ddd; padding-bottom: 10px;">{{ subject }}</h1>
        <p>{{ body }}</p>
        <a href="https://www.example.com" style="display: inline-block; padding: 10px 15px; margin-top: 20px; border-radius: 5px; background: #007BFF; color: #fff; text-decoration: none;">Visit Our Site</a>
    </div>
    <footer style="text-align: center; margin-top: 20px; font-size: 0.8em; color: #777;">
        &copy; 2024 Your Company. All rights reserved.
    </footer>
</body>
</html>

===================================================================================================
Settings for different environments
===================================================================================================

Read article:

Configuring Django Settings: Best Practices
https://djangostars.com/blog/configuring-django-settings-best-practices/#header7

****************************************************************
Create secret key:

from django.core.management.utils import get_random_secret_key

>>> from django.core.management.utils import get_random_secret_key

get_random_secret_key()


****************************************************************
12 Factors (set of best practices)
****************************************************************

The Twelve-Factor App methodology is a set of best practices for building scalable, maintainable, and deployable web applications. 
Here’s how these principles can be applied to a Django project:

### 1. **Codebase**: One codebase tracked in revision control, many deploys

- **Principle**: Maintain a single codebase for your application, stored in a version control system (e.g., Git), from which multiple deployments can be made.
- **Example**: Use Git or another VCS to track your Django project's codebase. Deploy the same codebase in multiple environments (dev, staging, prod).
    ```bash
    git init
    git add .
    git commit -m "Initial commit"
    ```

### 2. **Dependencies**: Explicitly declare and isolate dependencies

- **Principle**: Declare dependencies explicitly in a `requirements.txt` or `Pipfile`. Use virtual environments to isolate these dependencies.
- **Example**: Use a `requirements.txt` file and virtual environments.
    ```bash
    python -m venv venv
    source venv/bin/activate
    pip install django
    pip freeze > requirements.txt
    ```

### 3. **Config**: Store configuration in the environment

- **Principle**: Store configuration in environment variables rather than in the application code.
- **Example**: Use the `django-environ` package.
    ```python
    import environ
    env = environ.Env()
    environ.Env.read_env()

    SECRET_KEY = env('SECRET_KEY')
    DEBUG = env.bool('DEBUG', default=False)
    DATABASES = {
        'default': env.db(),
    }
    ```

### 4. **Backing Services**: Treat backing services as attached resources

- **Principle**: Treat databases, message queues, and other backing services as resources that can be attached and detached at any time. 
                   Connect to databases, caches, and other services using environment variables.
- **Example**: Configure a PostgreSQL database.
    ```python
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': env('DB_NAME'),
            'USER': env('DB_USER'),
            'PASSWORD': env('DB_PASSWORD'),
            'HOST': env('DB_HOST'),
            'PORT': env('DB_PORT'),
        }
    }
    ```

### 5. **Build, Release, Run**: Strictly separate build and run stages

- **Principle**: Separate the build, release, and run stages of your application. Build creates binaries, release combines build with config, and run executes the app.
                    Use tools like Docker or Heroku to handle the build and release phases. Ensure builds are immutable and releases are versioned.
- **Example**: Use a CI/CD pipeline to handle these stages.
    ```yaml
    stages:
      - build
      - release
      - deploy

    build:
      script:
        - python -m venv venv
        - source venv/bin/activate
        - pip install -r requirements.txt

    release:
      script:
        - python manage.py migrate

    deploy:
      script:
        - python manage.py runserver
    ```

### 6. **Processes**: Execute the app as one or more stateless processes

- **Principle**: Ensure that the app runs as stateless processes; any data that needs to persist should be stored in a stateful backing service.
                 Ensure the Django app is stateless and share nothing, relying on a stateful backing service like a database.
- **Example**: Running Django using Gunicorn.
    ```bash
    gunicorn myproject.wsgi:application --bind 0.0.0.0:8000
    ```

### 7. **Port Binding**: Export services via port binding

- **Principle**: The app should be self-contained and expose services by binding to a port.
- **Example**: Configure Django to bind to a specific port.
    ```bash
    python manage.py runserver 0.0.0.0:8000
    ```

### 8. **Concurrency**: Scale out via the process model

- **Principle**: Use multiple processes to handle concurrency. Use tools like gunicorn for multiple worker processes.
- **Example**: Use Gunicorn with multiple workers.
    ```bash
    gunicorn myproject.wsgi:application --workers 3 --bind 0.0.0.0:8000
    ```

### 9. **Disposability**: Maximize robustness with fast startup and graceful shutdown

- **Principle**: Make the app's processes disposable, allowing for quick startup and graceful shutdown. 
                 Ensure the app can start and stop quickly. Use Docker or similar tools for quick deployment and termination.
- **Example**: Implement signal handling in Django.
    ```python
    import signal
    import sys
    from django.core.management import BaseCommand

    class Command(BaseCommand):
        def handle(self, *args, **options):
            def graceful_shutdown(signum, frame):
                self.stdout.write("Shutting down gracefully...")
                sys.exit(0)
            
            signal.signal(signal.SIGTERM, graceful_shutdown)
            signal.signal(signal.SIGINT, graceful_shutdown)
            
            self.stdout.write("Running...")
            while True:
                pass
    ```

### 10. **Dev/Prod Parity**: Keep development, staging, and production as similar as possible

- **Principle**: Ensure that development, staging, and production environments are as similar as possible to avoid bugs that are only present in production.
- **Example**: Use Docker to create consistent environments.
    ```dockerfile
    FROM python:3.9-slim
    WORKDIR /app
    COPY . /app
    RUN pip install -r requirements.txt
    CMD ["gunicorn", "myproject.wsgi:application", "--bind", "0.0.0.0:8000"]
    ```

### 11. **Logs**: Treat logs as event streams

- **Principle**: Use Django's logging configuration to send logs to stdout/stderr. Aggregate and analyze logs using external tools.
- **Example**: Configure logging in Django.
    ```python
    LOGGING = {
        'version': 1,
        'disable_existing_loggers': False,
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
            },
        },
        'root': {
            'handlers': ['console'],
            'level': 'DEBUG',
        },
    }
    ```

### 12. **Admin Processes**: Run admin/management tasks as one-off processes

- **Principle**: Run administrative or maintenance tasks as one-off processes.
- **Example**: Use Django management commands for administrative tasks
    ```bash
    python manage.py migrate
    python manage.py createsuperuser
    python manage.py collectstatic
    ```

These principles help create scalable, maintainable, and robust web applications. 
By adhering to these guidelines, a Django application can be more easily managed and deployed in modern cloud environments.

****************************************************************
Middlewares
****************************************************************


****************************************************************
Internationalization and Localization
****************************************************************

The process of preparing an application to support more than one language and data format is called internationalization. Localization is the process of adapting an internationalized application to support a specific region or locale.

https://www.youtube.com/watch?v=leyCGPGiy3E

https://github.com/rootamin/django_internationalization

/home/dev/Downloads/django_internationalization-main.zip

===================================================================================================
Middleware in Django
===================================================================================================

Function based middleware:

1) create middleware in middleware.py file of the app:

def my_middleware(get_response):
    print("One Time Initialization")

    def my_function(request):
        print("This is before view")
        response = get_response(request)
        print("This is after view")
        return response
    return my_function


# The get_response callable might be the actual view (if this is the last listed middleware) or 
# it might be the next middleware in the chain.
# The current middleware doesn’t need to know or care what exactly it is, just that it represents whatever comes next.

2) Register the middleware in settings.py file:

MIDDLEWARE = [
    'blog.middlewares.my_middleware',
]

****************************************************************
Class Based middleware
****************************************************************

1) create middleware in middleware.py file of the app:

class MyMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        print("One Time Initialization")

    def __call__(self, request):
        print("This is before view")
        response = self.get_response(request)
        print("This is after view")
        return response


2) Register the middleware in settings.py file: 

 MIDDLEWARE = [
    'blog.middlewares.MyMiddleware'
]

****************************************************************
Middleware Hooks
****************************************************************

In Django, middleware provides a way to process requests globally before they reach the view, as well as responses before they reach the client. 
Middleware classes can also handle exceptions. The custom hooks are methods that you we define in our middleware to process views, exceptions, and template responses.

 Here's a detailed explanation of each:

### 1. `process_view(request, view_func, view_args, view_kwargs)`

This middleware hook is called just before Django calls the view. 
It can be used to perform tasks related to the view that will be executed.

- **Parameters:**
  - `request`: The HttpRequest object.
  - `view_func`: The actual view function that Django is about to call.
  - `view_args`: A list of positional arguments that will be passed to the view.
  - `view_kwargs`: A dictionary of keyword arguments that will be passed to the view.

- **Return Value:**
  - This method can return `None` or an `HttpResponse` object.
  - If it returns `None`, Django continues processing and eventually calls the view.
  - If it returns an `HttpResponse`, Django short-circuits and does not call the view; the response is returned immediately to the client.

- **Usage Example:**
  ```python
  class MyCustomMiddleware:
      def process_view(self, request, view_func, view_args, view_kwargs):
          # Example: Logging the view name
          print(f"About to call view: {view_func.__name__}")
          # Allow the request to proceed
          return None
  ```

### 2. `process_exception(request, exception)`

This hook is called when a view raises an exception. It's useful for logging, sending notifications, or transforming exceptions into user-friendly error messages.

- **Parameters:**
  - `request`: The HttpRequest object.
  - `exception`: The exception that was raised.

- **Return Value:**
  - This method can return `None` or an `HttpResponse` object.
  - If it returns `None`, Django's default exception handling continues.
  - If it returns an `HttpResponse`, Django uses that response, and default exception handling is bypassed.

- **Usage Example:**
  ```python
  class MyCustomMiddleware:
      def process_exception(self, request, exception):
          # Example: Logging the exception
          print(f"Exception occurred: {exception}")
          # Returning a custom error response
          return HttpResponse("An error occurred", status=500)
  ```

### 3. `process_template_response(request, response)`

This hook is called when a view returns a `TemplateResponse` (or a subclass). 
It allows you to modify the template response before it is rendered and sent to the client.

- **Parameters:**
  - `request`: The HttpRequest object.
  - `response`: The TemplateResponse object that is about to be returned.

- **Return Value:**
  - This method should return a `TemplateResponse` object, which can be the original response or a modified version.

- **Usage Example:**
  ```python
  class MyCustomMiddleware:
      def process_template_response(self, request, response):
          # Example: Adding a variable to the context
          response.context_data['additional_data'] = 'This is extra data'
          # Returning the (possibly modified) response
          return response
  ```

These hooks allow middleware to intervene at specific points during the request/response cycle, providing powerful ways to influence the behavior of your Django application.

*****************************************************
Middleware Hooks Use case example:
*****************************************************

Sure! Let's create an example middleware that demonstrates the use of all three hooks: `process_view`, `process_exception`, and `process_template_response`. 
This middleware will log information about the view being processed, handle exceptions by logging them and providing a custom error response, and modify template responses to include additional context data.

### Example Middleware

```python
from django.http import HttpResponse
from django.template.response import TemplateResponse

class MyCustomMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)
        return response

    def process_view(self, request, view_func, view_args, view_kwargs):
        # Logging the name of the view function that is about to be called
        print(f"About to call view: {view_func.__name__}")
        # Allow the request to proceed
        return None

    def process_exception(self, request, exception):
        # Logging the exception
        print(f"Exception occurred: {exception}")
        # Returning a custom error response
        return HttpResponse("An error occurred, and we are working on it.", status=500)

    def process_template_response(self, request, response):
        # Adding a variable to the context of the template response
        if isinstance(response, TemplateResponse):
            response.context_data['additional_data'] = 'This is extra data from middleware'
        # Returning the (possibly modified) response
        return response
```

### Explanation

1. **Initialization and Call Method:**
   - The `__init__` method initializes the middleware with the next callable in the chain (`get_response`).
   - The `__call__` method processes the request and gets the response by calling the next middleware or view.

2. **`process_view` Hook:**
   - Before the view is called, this hook logs the name of the view function.
   - It then returns `None` to allow Django to continue processing and eventually call the view.

3. **`process_exception` Hook:**
   - If an exception is raised during view processing, this hook logs the exception message.
   - It returns an `HttpResponse` with a custom error message and a 500 status code, effectively handling the exception.

4. **`process_template_response` Hook:**
   - If the response is a `TemplateResponse`, this hook adds an extra context variable (`additional_data`) to the template context.
   - It then returns the modified (or original) response.

### Using the Middleware

To use this middleware, you need to add it to your `MIDDLEWARE` setting in `settings.py`:

```python
MIDDLEWARE = [
    # Other middleware classes
    'path.to.MyCustomMiddleware',
    # More middleware classes
]
```

### Scenario Demonstration

- **Normal Request Flow:** When a request is made, `process_view` logs the view function's name. If the view returns a `TemplateResponse`, `process_template_response` adds extra context data.
- **Exception Handling:** If an exception occurs during the view processing, `process_exception` logs the exception and returns a custom error response.

This example shows how you can utilize these middleware hooks to handle various aspects of request and response processing in Django.

*****************************************************
Built-In middlewares
*****************************************************

Django provides several built-in middlewares that handle various aspects of request and response processing. 
Middleware in Django is a way to process requests globally before they reach the view or after the view has processed them. 

Here is an explanation of all the built-in middlewares in Django along with their use cases:

### 1. `django.middleware.security.SecurityMiddleware`
**Use Case:** Enhances security settings.
- **Description:** Implements several security enhancements, including setting HTTP headers that prevent certain security vulnerabilities (e.g., XSS, Clickjacking).
- **Example:** Sets the `Strict-Transport-Security` header for HTTPS, redirects HTTP requests to HTTPS, and handles settings like `SECURE_BROWSER_XSS_FILTER` and `SECURE_CONTENT_TYPE_NOSNIFF`.

### 2. `django.contrib.sessions.middleware.SessionMiddleware`
**Use Case:** Manages user sessions.
- **Description:** Adds session management to requests. It enables storing and retrieving arbitrary data on a per-site-visitor basis.
- **Example:** Used for user login functionality where you need to persist user information across requests.

### 3. `django.middleware.common.CommonMiddleware`
**Use Case:** Implements various common functionalities.
- **Description:** Performs URL rewriting and handling common tasks like appending slashes to URLs and managing redirects.
- **Example:** Automatically appends a slash at the end of URLs if `APPEND_SLASH` is set to `True`.

### 4. `django.middleware.csrf.CsrfViewMiddleware`
**Use Case:** Protects against Cross-Site Request Forgery (CSRF) attacks.
- **Description:** Ensures that forms submitted via POST requests are protected against CSRF attacks by checking for a valid token.
- **Example:** When creating forms in a Django application, this middleware ensures that each form contains a CSRF token.

### 5. `django.middleware.gzip.GZipMiddleware`
**Use Case:** Compresses content for clients that support gzip.
- **Description:** Compresses responses if the client supports gzip, reducing the amount of data transferred and improving load times.
- **Example:** Suitable for large JSON responses from an API, reducing the payload size and speeding up the response.

### 6. `django.middleware.http.ConditionalGetMiddleware`
**Use Case:** Implements HTTP conditional GET handling.
- **Description:** Supports the use of the `ETag` and `Last-Modified` headers to determine if a response has changed and whether a new response needs to be sent.
- **Example:** Efficiently serves cached content by returning a 304 Not Modified response when appropriate.

### 7. `django.middleware.locale.LocaleMiddleware`
**Use Case:** Manages language preferences.
- **Description:** Enables language selection based on data from the request (e.g., cookies, session, browser settings).
- **Example:** Automatically switches languages based on user preferences or browser settings for multilingual sites.

### 8. `django.middleware.common.BrokenLinkEmailsMiddleware`
**Use Case:** Sends emails about broken links.
- **Description:** Emails site administrators when a broken link is encountered.
- **Example:** Useful for monitoring and fixing broken links, though it's not included in the default middleware stack and needs to be added manually.

### 9. `django.contrib.messages.middleware.MessageMiddleware`
**Use Case:** Manages temporary messages.
- **Description:** Provides a way to queue and display temporary messages to users (e.g., success or error messages).
- **Example:** After a form is submitted successfully, a success message can be displayed to the user.

### 10. `django.middleware.clickjacking.XFrameOptionsMiddleware`
**Use Case:** Provides protection against clickjacking.
- **Description:** Sets the `X-Frame-Options` HTTP header to control whether the site can be embedded in an iframe.
- **Example:** Prevents your site from being embedded in other sites' iframes, which can help mitigate clickjacking attacks.

### 11. `django.middleware.cache.UpdateCacheMiddleware` and `django.middleware.cache.FetchFromCacheMiddleware`
**Use Case:** Implements site-wide caching.
- **Description:** `UpdateCacheMiddleware` caches the response to be served for subsequent requests, and `FetchFromCacheMiddleware` fetches the response from the cache.
- **Example:** Suitable for caching entire pages or site sections to improve performance by reducing database queries and processing time.

### 12. `django.middleware.transaction.TransactionMiddleware`
**Use Case:** Manages database transactions.
- **Description:** Ensures that each request is wrapped in a database transaction, committing it at the end if no exceptions occur.
- **Example:** Useful in ensuring atomicity for complex view logic that involves multiple database operations.

These built-in middlewares cover a wide range of functionalities, from security enhancements and session management to caching and localization. By leveraging these middlewares, developers can address many common requirements and improve the robustness and performance of their Django applications.

===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================



===================================================================================================
===================================================================================================

